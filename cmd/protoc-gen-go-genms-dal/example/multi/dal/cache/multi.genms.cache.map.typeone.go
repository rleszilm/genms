// Package cache_dal_multi is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package cache_dal_multi

import (
	context "context"
	fmt "fmt"
	time "time"

	cache "github.com/rleszilm/genms/cache"
	multi "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/multi"
	service "github.com/rleszilm/genms/service"
	stats "go.opencensus.io/stats"
	tag "go.opencensus.io/tag"
)

// TypeOneMap defines a Map base cache implementing TypeOneReadWriter.
// If a key is queries that does not exist an attempt to read and store it is made.
type TypeOneMap struct {
	service.Dependencies
	UnimplementedTypeOneCache

	name   string
	reader TypeOneReader
	writer TypeOneWriter
	cache  map[TypeOneKey]*multi.TypeOne
	all    []*multi.TypeOne
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *TypeOneMap) Initialize(ctx context.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *TypeOneMap) Shutdown(_ context.Context) error {
	return nil
}

// String returns the name of the map.
func (x *TypeOneMap) String() string {
	if x.name != "" {
		return x.name
	}
	return "cache-dal-multi-type-one-map"
}

// NameOf returns the name of the map.
func (x *TypeOneMap) NameOf() string {
	return x.String()
}

// All implements implements TypeOneReadAller.
func (x *TypeOneMap) All(ctx context.Context) ([]*multi.TypeOne, error) {
	start := time.Now()
	ctx, _ = tag.New(ctx,
		tag.Upsert(cache.TagCollection, "type_one"),
		tag.Upsert(cache.TagInstance, x.name),
		tag.Upsert(cache.TagMethod, "all"),
		tag.Upsert(cache.TagType, "map"),
	)
	stats.Record(ctx, cache.MeasureInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, cache.MeasureLatency.M(dur), cache.MeasureInflight.M(-1))
	}()

	return x.all, nil
}

// Get implements TypeOneReader.
func (x *TypeOneMap) Get(ctx context.Context, key TypeOneKey) (*multi.TypeOne, error) {
	start := time.Now()
	ctx, _ = tag.New(ctx,
		tag.Upsert(cache.TagCollection, "type_one"),
		tag.Upsert(cache.TagInstance, x.name),
		tag.Upsert(cache.TagMethod, "get"),
		tag.Upsert(cache.TagType, "map"),
	)
	stats.Record(ctx, cache.MeasureInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, cache.MeasureLatency.M(dur), cache.MeasureInflight.M(-1))
	}()

	if val, ok := x.cache[key]; ok {
		return val, nil
	}

	if x.reader != nil {
		val, err := x.reader.Get(ctx, key)
		if err != nil {
			return nil, fmt.Errorf("map: TypeOne.Get - %w", err)
		}
		x.cache[key] = val
		return val, nil
	}

	stats.Record(ctx, cache.MeasureError.M(1))
	return nil, fmt.Errorf("map: TypeOne.Get - %w", cache.ErrNoValue)
}

// Set implements TypeOneWriter.
func (x *TypeOneMap) Set(ctx context.Context, key TypeOneKey, val *multi.TypeOne) (*multi.TypeOne, error) {
	start := time.Now()
	ctx, _ = tag.New(ctx,
		tag.Upsert(cache.TagCollection, "type_one"),
		tag.Upsert(cache.TagInstance, x.name),
		tag.Upsert(cache.TagMethod, "get"),
		tag.Upsert(cache.TagType, "map"),
	)
	stats.Record(ctx, cache.MeasureInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, cache.MeasureLatency.M(dur), cache.MeasureInflight.M(-1))
	}()

	if x.writer != nil {
		upd, err := x.writer.Set(ctx, key, val)
		if err != nil {
			stats.Record(ctx, cache.MeasureError.M(1))
			return nil, fmt.Errorf("map: TypeOne.Set - %w", err)
		}
		val = upd
	}

	x.cache[key] = val

	all := []*multi.TypeOne{}
	for _, v := range x.cache {
		all = append(all, v)
	}
	x.all = all

	return val, nil
}

// WithReader tells the TypeOneMap where to source values from if they don't exist in cache.
func (x *TypeOneMap) WithReader(r TypeOneReader) {
	x.reader = r
}

// WithWriter tells the TypeOneMap where to source values from if they don't exist in cache.
func (x *TypeOneMap) WithWriter(w TypeOneWriter) {
	x.writer = w
}

// NewTypeOneMap returns a new TypeOneMap cache.
func NewTypeOneMap(name string) (*TypeOneMap, error) {
	return &TypeOneMap{
		name:  name,
		cache: map[TypeOneKey]*multi.TypeOne{},
	}, nil
}
