// Code generated by counterfeiter. DO NOT EDIT.
package dalfakes

import (
	"context"
	"sync"

	"github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/multi"
	dal_multi "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/multi/dal"
	"github.com/rleszilm/genms/service"
)

type FakeTypeTwoCollection struct {
	AllStub        func(context.Context) ([]*multi.TypeTwo, error)
	allMutex       sync.RWMutex
	allArgsForCall []struct {
		arg1 context.Context
	}
	allReturns struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	allReturnsOnCall map[int]struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	DependantsStub        func() service.Services
	dependantsMutex       sync.RWMutex
	dependantsArgsForCall []struct {
	}
	dependantsReturns struct {
		result1 service.Services
	}
	dependantsReturnsOnCall map[int]struct {
		result1 service.Services
	}
	FilterStub        func(context.Context, *dal_multi.TypeTwoFieldValues) ([]*multi.TypeTwo, error)
	filterMutex       sync.RWMutex
	filterArgsForCall []struct {
		arg1 context.Context
		arg2 *dal_multi.TypeTwoFieldValues
	}
	filterReturns struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	filterReturnsOnCall map[int]struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	InitializeStub        func(context.Context) error
	initializeMutex       sync.RWMutex
	initializeArgsForCall []struct {
		arg1 context.Context
	}
	initializeReturns struct {
		result1 error
	}
	initializeReturnsOnCall map[int]struct {
		result1 error
	}
	InsertStub        func(context.Context, *multi.TypeTwo) (*multi.TypeTwo, error)
	insertMutex       sync.RWMutex
	insertArgsForCall []struct {
		arg1 context.Context
		arg2 *multi.TypeTwo
	}
	insertReturns struct {
		result1 *multi.TypeTwo
		result2 error
	}
	insertReturnsOnCall map[int]struct {
		result1 *multi.TypeTwo
		result2 error
	}
	InterfaceStubOnlyStub        func(context.Context) ([]*multi.TypeTwo, error)
	interfaceStubOnlyMutex       sync.RWMutex
	interfaceStubOnlyArgsForCall []struct {
		arg1 context.Context
	}
	interfaceStubOnlyReturns struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	interfaceStubOnlyReturnsOnCall map[int]struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	MessageParamStub        func(context.Context, *multi.TypeTwo_Message) ([]*multi.TypeTwo, error)
	messageParamMutex       sync.RWMutex
	messageParamArgsForCall []struct {
		arg1 context.Context
		arg2 *multi.TypeTwo_Message
	}
	messageParamReturns struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	messageParamReturnsOnCall map[int]struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	MultipleParamStub        func(context.Context, int32, int64, float32) ([]*multi.TypeTwo, error)
	multipleParamMutex       sync.RWMutex
	multipleParamArgsForCall []struct {
		arg1 context.Context
		arg2 int32
		arg3 int64
		arg4 float32
	}
	multipleParamReturns struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	multipleParamReturnsOnCall map[int]struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	NameOfStub        func() string
	nameOfMutex       sync.RWMutex
	nameOfArgsForCall []struct {
	}
	nameOfReturns struct {
		result1 string
	}
	nameOfReturnsOnCall map[int]struct {
		result1 string
	}
	OneParamStub        func(context.Context, int32) ([]*multi.TypeTwo, error)
	oneParamMutex       sync.RWMutex
	oneParamArgsForCall []struct {
		arg1 context.Context
		arg2 int32
	}
	oneParamReturns struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	oneParamReturnsOnCall map[int]struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	ProviderStubOnlyStub        func(context.Context) ([]*multi.TypeTwo, error)
	providerStubOnlyMutex       sync.RWMutex
	providerStubOnlyArgsForCall []struct {
		arg1 context.Context
	}
	providerStubOnlyReturns struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	providerStubOnlyReturnsOnCall map[int]struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	ShutdownStub        func(context.Context) error
	shutdownMutex       sync.RWMutex
	shutdownArgsForCall []struct {
		arg1 context.Context
	}
	shutdownReturns struct {
		result1 error
	}
	shutdownReturnsOnCall map[int]struct {
		result1 error
	}
	StringStub        func() string
	stringMutex       sync.RWMutex
	stringArgsForCall []struct {
	}
	stringReturns struct {
		result1 string
	}
	stringReturnsOnCall map[int]struct {
		result1 string
	}
	UpdateStub        func(context.Context, *multi.TypeTwo, *dal_multi.TypeTwoFieldValues) (*multi.TypeTwo, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 *multi.TypeTwo
		arg3 *dal_multi.TypeTwoFieldValues
	}
	updateReturns struct {
		result1 *multi.TypeTwo
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *multi.TypeTwo
		result2 error
	}
	UpsertStub        func(context.Context, *multi.TypeTwo) (*multi.TypeTwo, error)
	upsertMutex       sync.RWMutex
	upsertArgsForCall []struct {
		arg1 context.Context
		arg2 *multi.TypeTwo
	}
	upsertReturns struct {
		result1 *multi.TypeTwo
		result2 error
	}
	upsertReturnsOnCall map[int]struct {
		result1 *multi.TypeTwo
		result2 error
	}
	WithComparatorStub        func(context.Context, int32) ([]*multi.TypeTwo, error)
	withComparatorMutex       sync.RWMutex
	withComparatorArgsForCall []struct {
		arg1 context.Context
		arg2 int32
	}
	withComparatorReturns struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	withComparatorReturnsOnCall map[int]struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	WithDependenciesStub        func(...service.Service)
	withDependenciesMutex       sync.RWMutex
	withDependenciesArgsForCall []struct {
		arg1 []service.Service
	}
	WithRestStub        func(context.Context, int32, int64, float32, float64) ([]*multi.TypeTwo, error)
	withRestMutex       sync.RWMutex
	withRestArgsForCall []struct {
		arg1 context.Context
		arg2 int32
		arg3 int64
		arg4 float32
		arg5 float64
	}
	withRestReturns struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	withRestReturnsOnCall map[int]struct {
		result1 []*multi.TypeTwo
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTypeTwoCollection) All(arg1 context.Context) ([]*multi.TypeTwo, error) {
	fake.allMutex.Lock()
	ret, specificReturn := fake.allReturnsOnCall[len(fake.allArgsForCall)]
	fake.allArgsForCall = append(fake.allArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("All", []interface{}{arg1})
	fake.allMutex.Unlock()
	if fake.AllStub != nil {
		return fake.AllStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.allReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypeTwoCollection) AllCallCount() int {
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	return len(fake.allArgsForCall)
}

func (fake *FakeTypeTwoCollection) AllCalls(stub func(context.Context) ([]*multi.TypeTwo, error)) {
	fake.allMutex.Lock()
	defer fake.allMutex.Unlock()
	fake.AllStub = stub
}

func (fake *FakeTypeTwoCollection) AllArgsForCall(i int) context.Context {
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	argsForCall := fake.allArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTypeTwoCollection) AllReturns(result1 []*multi.TypeTwo, result2 error) {
	fake.allMutex.Lock()
	defer fake.allMutex.Unlock()
	fake.AllStub = nil
	fake.allReturns = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) AllReturnsOnCall(i int, result1 []*multi.TypeTwo, result2 error) {
	fake.allMutex.Lock()
	defer fake.allMutex.Unlock()
	fake.AllStub = nil
	if fake.allReturnsOnCall == nil {
		fake.allReturnsOnCall = make(map[int]struct {
			result1 []*multi.TypeTwo
			result2 error
		})
	}
	fake.allReturnsOnCall[i] = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) Dependants() service.Services {
	fake.dependantsMutex.Lock()
	ret, specificReturn := fake.dependantsReturnsOnCall[len(fake.dependantsArgsForCall)]
	fake.dependantsArgsForCall = append(fake.dependantsArgsForCall, struct {
	}{})
	fake.recordInvocation("Dependants", []interface{}{})
	fake.dependantsMutex.Unlock()
	if fake.DependantsStub != nil {
		return fake.DependantsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.dependantsReturns
	return fakeReturns.result1
}

func (fake *FakeTypeTwoCollection) DependantsCallCount() int {
	fake.dependantsMutex.RLock()
	defer fake.dependantsMutex.RUnlock()
	return len(fake.dependantsArgsForCall)
}

func (fake *FakeTypeTwoCollection) DependantsCalls(stub func() service.Services) {
	fake.dependantsMutex.Lock()
	defer fake.dependantsMutex.Unlock()
	fake.DependantsStub = stub
}

func (fake *FakeTypeTwoCollection) DependantsReturns(result1 service.Services) {
	fake.dependantsMutex.Lock()
	defer fake.dependantsMutex.Unlock()
	fake.DependantsStub = nil
	fake.dependantsReturns = struct {
		result1 service.Services
	}{result1}
}

func (fake *FakeTypeTwoCollection) DependantsReturnsOnCall(i int, result1 service.Services) {
	fake.dependantsMutex.Lock()
	defer fake.dependantsMutex.Unlock()
	fake.DependantsStub = nil
	if fake.dependantsReturnsOnCall == nil {
		fake.dependantsReturnsOnCall = make(map[int]struct {
			result1 service.Services
		})
	}
	fake.dependantsReturnsOnCall[i] = struct {
		result1 service.Services
	}{result1}
}

func (fake *FakeTypeTwoCollection) Filter(arg1 context.Context, arg2 *dal_multi.TypeTwoFieldValues) ([]*multi.TypeTwo, error) {
	fake.filterMutex.Lock()
	ret, specificReturn := fake.filterReturnsOnCall[len(fake.filterArgsForCall)]
	fake.filterArgsForCall = append(fake.filterArgsForCall, struct {
		arg1 context.Context
		arg2 *dal_multi.TypeTwoFieldValues
	}{arg1, arg2})
	fake.recordInvocation("Filter", []interface{}{arg1, arg2})
	fake.filterMutex.Unlock()
	if fake.FilterStub != nil {
		return fake.FilterStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.filterReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypeTwoCollection) FilterCallCount() int {
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	return len(fake.filterArgsForCall)
}

func (fake *FakeTypeTwoCollection) FilterCalls(stub func(context.Context, *dal_multi.TypeTwoFieldValues) ([]*multi.TypeTwo, error)) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = stub
}

func (fake *FakeTypeTwoCollection) FilterArgsForCall(i int) (context.Context, *dal_multi.TypeTwoFieldValues) {
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	argsForCall := fake.filterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTypeTwoCollection) FilterReturns(result1 []*multi.TypeTwo, result2 error) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = nil
	fake.filterReturns = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) FilterReturnsOnCall(i int, result1 []*multi.TypeTwo, result2 error) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = nil
	if fake.filterReturnsOnCall == nil {
		fake.filterReturnsOnCall = make(map[int]struct {
			result1 []*multi.TypeTwo
			result2 error
		})
	}
	fake.filterReturnsOnCall[i] = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) Initialize(arg1 context.Context) error {
	fake.initializeMutex.Lock()
	ret, specificReturn := fake.initializeReturnsOnCall[len(fake.initializeArgsForCall)]
	fake.initializeArgsForCall = append(fake.initializeArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Initialize", []interface{}{arg1})
	fake.initializeMutex.Unlock()
	if fake.InitializeStub != nil {
		return fake.InitializeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.initializeReturns
	return fakeReturns.result1
}

func (fake *FakeTypeTwoCollection) InitializeCallCount() int {
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	return len(fake.initializeArgsForCall)
}

func (fake *FakeTypeTwoCollection) InitializeCalls(stub func(context.Context) error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = stub
}

func (fake *FakeTypeTwoCollection) InitializeArgsForCall(i int) context.Context {
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	argsForCall := fake.initializeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTypeTwoCollection) InitializeReturns(result1 error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = nil
	fake.initializeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTypeTwoCollection) InitializeReturnsOnCall(i int, result1 error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = nil
	if fake.initializeReturnsOnCall == nil {
		fake.initializeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initializeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTypeTwoCollection) Insert(arg1 context.Context, arg2 *multi.TypeTwo) (*multi.TypeTwo, error) {
	fake.insertMutex.Lock()
	ret, specificReturn := fake.insertReturnsOnCall[len(fake.insertArgsForCall)]
	fake.insertArgsForCall = append(fake.insertArgsForCall, struct {
		arg1 context.Context
		arg2 *multi.TypeTwo
	}{arg1, arg2})
	fake.recordInvocation("Insert", []interface{}{arg1, arg2})
	fake.insertMutex.Unlock()
	if fake.InsertStub != nil {
		return fake.InsertStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.insertReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypeTwoCollection) InsertCallCount() int {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	return len(fake.insertArgsForCall)
}

func (fake *FakeTypeTwoCollection) InsertCalls(stub func(context.Context, *multi.TypeTwo) (*multi.TypeTwo, error)) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = stub
}

func (fake *FakeTypeTwoCollection) InsertArgsForCall(i int) (context.Context, *multi.TypeTwo) {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	argsForCall := fake.insertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTypeTwoCollection) InsertReturns(result1 *multi.TypeTwo, result2 error) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = nil
	fake.insertReturns = struct {
		result1 *multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) InsertReturnsOnCall(i int, result1 *multi.TypeTwo, result2 error) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = nil
	if fake.insertReturnsOnCall == nil {
		fake.insertReturnsOnCall = make(map[int]struct {
			result1 *multi.TypeTwo
			result2 error
		})
	}
	fake.insertReturnsOnCall[i] = struct {
		result1 *multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) InterfaceStubOnly(arg1 context.Context) ([]*multi.TypeTwo, error) {
	fake.interfaceStubOnlyMutex.Lock()
	ret, specificReturn := fake.interfaceStubOnlyReturnsOnCall[len(fake.interfaceStubOnlyArgsForCall)]
	fake.interfaceStubOnlyArgsForCall = append(fake.interfaceStubOnlyArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("InterfaceStubOnly", []interface{}{arg1})
	fake.interfaceStubOnlyMutex.Unlock()
	if fake.InterfaceStubOnlyStub != nil {
		return fake.InterfaceStubOnlyStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.interfaceStubOnlyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypeTwoCollection) InterfaceStubOnlyCallCount() int {
	fake.interfaceStubOnlyMutex.RLock()
	defer fake.interfaceStubOnlyMutex.RUnlock()
	return len(fake.interfaceStubOnlyArgsForCall)
}

func (fake *FakeTypeTwoCollection) InterfaceStubOnlyCalls(stub func(context.Context) ([]*multi.TypeTwo, error)) {
	fake.interfaceStubOnlyMutex.Lock()
	defer fake.interfaceStubOnlyMutex.Unlock()
	fake.InterfaceStubOnlyStub = stub
}

func (fake *FakeTypeTwoCollection) InterfaceStubOnlyArgsForCall(i int) context.Context {
	fake.interfaceStubOnlyMutex.RLock()
	defer fake.interfaceStubOnlyMutex.RUnlock()
	argsForCall := fake.interfaceStubOnlyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTypeTwoCollection) InterfaceStubOnlyReturns(result1 []*multi.TypeTwo, result2 error) {
	fake.interfaceStubOnlyMutex.Lock()
	defer fake.interfaceStubOnlyMutex.Unlock()
	fake.InterfaceStubOnlyStub = nil
	fake.interfaceStubOnlyReturns = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) InterfaceStubOnlyReturnsOnCall(i int, result1 []*multi.TypeTwo, result2 error) {
	fake.interfaceStubOnlyMutex.Lock()
	defer fake.interfaceStubOnlyMutex.Unlock()
	fake.InterfaceStubOnlyStub = nil
	if fake.interfaceStubOnlyReturnsOnCall == nil {
		fake.interfaceStubOnlyReturnsOnCall = make(map[int]struct {
			result1 []*multi.TypeTwo
			result2 error
		})
	}
	fake.interfaceStubOnlyReturnsOnCall[i] = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) MessageParam(arg1 context.Context, arg2 *multi.TypeTwo_Message) ([]*multi.TypeTwo, error) {
	fake.messageParamMutex.Lock()
	ret, specificReturn := fake.messageParamReturnsOnCall[len(fake.messageParamArgsForCall)]
	fake.messageParamArgsForCall = append(fake.messageParamArgsForCall, struct {
		arg1 context.Context
		arg2 *multi.TypeTwo_Message
	}{arg1, arg2})
	fake.recordInvocation("MessageParam", []interface{}{arg1, arg2})
	fake.messageParamMutex.Unlock()
	if fake.MessageParamStub != nil {
		return fake.MessageParamStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.messageParamReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypeTwoCollection) MessageParamCallCount() int {
	fake.messageParamMutex.RLock()
	defer fake.messageParamMutex.RUnlock()
	return len(fake.messageParamArgsForCall)
}

func (fake *FakeTypeTwoCollection) MessageParamCalls(stub func(context.Context, *multi.TypeTwo_Message) ([]*multi.TypeTwo, error)) {
	fake.messageParamMutex.Lock()
	defer fake.messageParamMutex.Unlock()
	fake.MessageParamStub = stub
}

func (fake *FakeTypeTwoCollection) MessageParamArgsForCall(i int) (context.Context, *multi.TypeTwo_Message) {
	fake.messageParamMutex.RLock()
	defer fake.messageParamMutex.RUnlock()
	argsForCall := fake.messageParamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTypeTwoCollection) MessageParamReturns(result1 []*multi.TypeTwo, result2 error) {
	fake.messageParamMutex.Lock()
	defer fake.messageParamMutex.Unlock()
	fake.MessageParamStub = nil
	fake.messageParamReturns = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) MessageParamReturnsOnCall(i int, result1 []*multi.TypeTwo, result2 error) {
	fake.messageParamMutex.Lock()
	defer fake.messageParamMutex.Unlock()
	fake.MessageParamStub = nil
	if fake.messageParamReturnsOnCall == nil {
		fake.messageParamReturnsOnCall = make(map[int]struct {
			result1 []*multi.TypeTwo
			result2 error
		})
	}
	fake.messageParamReturnsOnCall[i] = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) MultipleParam(arg1 context.Context, arg2 int32, arg3 int64, arg4 float32) ([]*multi.TypeTwo, error) {
	fake.multipleParamMutex.Lock()
	ret, specificReturn := fake.multipleParamReturnsOnCall[len(fake.multipleParamArgsForCall)]
	fake.multipleParamArgsForCall = append(fake.multipleParamArgsForCall, struct {
		arg1 context.Context
		arg2 int32
		arg3 int64
		arg4 float32
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("MultipleParam", []interface{}{arg1, arg2, arg3, arg4})
	fake.multipleParamMutex.Unlock()
	if fake.MultipleParamStub != nil {
		return fake.MultipleParamStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.multipleParamReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypeTwoCollection) MultipleParamCallCount() int {
	fake.multipleParamMutex.RLock()
	defer fake.multipleParamMutex.RUnlock()
	return len(fake.multipleParamArgsForCall)
}

func (fake *FakeTypeTwoCollection) MultipleParamCalls(stub func(context.Context, int32, int64, float32) ([]*multi.TypeTwo, error)) {
	fake.multipleParamMutex.Lock()
	defer fake.multipleParamMutex.Unlock()
	fake.MultipleParamStub = stub
}

func (fake *FakeTypeTwoCollection) MultipleParamArgsForCall(i int) (context.Context, int32, int64, float32) {
	fake.multipleParamMutex.RLock()
	defer fake.multipleParamMutex.RUnlock()
	argsForCall := fake.multipleParamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTypeTwoCollection) MultipleParamReturns(result1 []*multi.TypeTwo, result2 error) {
	fake.multipleParamMutex.Lock()
	defer fake.multipleParamMutex.Unlock()
	fake.MultipleParamStub = nil
	fake.multipleParamReturns = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) MultipleParamReturnsOnCall(i int, result1 []*multi.TypeTwo, result2 error) {
	fake.multipleParamMutex.Lock()
	defer fake.multipleParamMutex.Unlock()
	fake.MultipleParamStub = nil
	if fake.multipleParamReturnsOnCall == nil {
		fake.multipleParamReturnsOnCall = make(map[int]struct {
			result1 []*multi.TypeTwo
			result2 error
		})
	}
	fake.multipleParamReturnsOnCall[i] = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) NameOf() string {
	fake.nameOfMutex.Lock()
	ret, specificReturn := fake.nameOfReturnsOnCall[len(fake.nameOfArgsForCall)]
	fake.nameOfArgsForCall = append(fake.nameOfArgsForCall, struct {
	}{})
	fake.recordInvocation("NameOf", []interface{}{})
	fake.nameOfMutex.Unlock()
	if fake.NameOfStub != nil {
		return fake.NameOfStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nameOfReturns
	return fakeReturns.result1
}

func (fake *FakeTypeTwoCollection) NameOfCallCount() int {
	fake.nameOfMutex.RLock()
	defer fake.nameOfMutex.RUnlock()
	return len(fake.nameOfArgsForCall)
}

func (fake *FakeTypeTwoCollection) NameOfCalls(stub func() string) {
	fake.nameOfMutex.Lock()
	defer fake.nameOfMutex.Unlock()
	fake.NameOfStub = stub
}

func (fake *FakeTypeTwoCollection) NameOfReturns(result1 string) {
	fake.nameOfMutex.Lock()
	defer fake.nameOfMutex.Unlock()
	fake.NameOfStub = nil
	fake.nameOfReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTypeTwoCollection) NameOfReturnsOnCall(i int, result1 string) {
	fake.nameOfMutex.Lock()
	defer fake.nameOfMutex.Unlock()
	fake.NameOfStub = nil
	if fake.nameOfReturnsOnCall == nil {
		fake.nameOfReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameOfReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTypeTwoCollection) OneParam(arg1 context.Context, arg2 int32) ([]*multi.TypeTwo, error) {
	fake.oneParamMutex.Lock()
	ret, specificReturn := fake.oneParamReturnsOnCall[len(fake.oneParamArgsForCall)]
	fake.oneParamArgsForCall = append(fake.oneParamArgsForCall, struct {
		arg1 context.Context
		arg2 int32
	}{arg1, arg2})
	fake.recordInvocation("OneParam", []interface{}{arg1, arg2})
	fake.oneParamMutex.Unlock()
	if fake.OneParamStub != nil {
		return fake.OneParamStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.oneParamReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypeTwoCollection) OneParamCallCount() int {
	fake.oneParamMutex.RLock()
	defer fake.oneParamMutex.RUnlock()
	return len(fake.oneParamArgsForCall)
}

func (fake *FakeTypeTwoCollection) OneParamCalls(stub func(context.Context, int32) ([]*multi.TypeTwo, error)) {
	fake.oneParamMutex.Lock()
	defer fake.oneParamMutex.Unlock()
	fake.OneParamStub = stub
}

func (fake *FakeTypeTwoCollection) OneParamArgsForCall(i int) (context.Context, int32) {
	fake.oneParamMutex.RLock()
	defer fake.oneParamMutex.RUnlock()
	argsForCall := fake.oneParamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTypeTwoCollection) OneParamReturns(result1 []*multi.TypeTwo, result2 error) {
	fake.oneParamMutex.Lock()
	defer fake.oneParamMutex.Unlock()
	fake.OneParamStub = nil
	fake.oneParamReturns = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) OneParamReturnsOnCall(i int, result1 []*multi.TypeTwo, result2 error) {
	fake.oneParamMutex.Lock()
	defer fake.oneParamMutex.Unlock()
	fake.OneParamStub = nil
	if fake.oneParamReturnsOnCall == nil {
		fake.oneParamReturnsOnCall = make(map[int]struct {
			result1 []*multi.TypeTwo
			result2 error
		})
	}
	fake.oneParamReturnsOnCall[i] = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) ProviderStubOnly(arg1 context.Context) ([]*multi.TypeTwo, error) {
	fake.providerStubOnlyMutex.Lock()
	ret, specificReturn := fake.providerStubOnlyReturnsOnCall[len(fake.providerStubOnlyArgsForCall)]
	fake.providerStubOnlyArgsForCall = append(fake.providerStubOnlyArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("ProviderStubOnly", []interface{}{arg1})
	fake.providerStubOnlyMutex.Unlock()
	if fake.ProviderStubOnlyStub != nil {
		return fake.ProviderStubOnlyStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.providerStubOnlyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypeTwoCollection) ProviderStubOnlyCallCount() int {
	fake.providerStubOnlyMutex.RLock()
	defer fake.providerStubOnlyMutex.RUnlock()
	return len(fake.providerStubOnlyArgsForCall)
}

func (fake *FakeTypeTwoCollection) ProviderStubOnlyCalls(stub func(context.Context) ([]*multi.TypeTwo, error)) {
	fake.providerStubOnlyMutex.Lock()
	defer fake.providerStubOnlyMutex.Unlock()
	fake.ProviderStubOnlyStub = stub
}

func (fake *FakeTypeTwoCollection) ProviderStubOnlyArgsForCall(i int) context.Context {
	fake.providerStubOnlyMutex.RLock()
	defer fake.providerStubOnlyMutex.RUnlock()
	argsForCall := fake.providerStubOnlyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTypeTwoCollection) ProviderStubOnlyReturns(result1 []*multi.TypeTwo, result2 error) {
	fake.providerStubOnlyMutex.Lock()
	defer fake.providerStubOnlyMutex.Unlock()
	fake.ProviderStubOnlyStub = nil
	fake.providerStubOnlyReturns = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) ProviderStubOnlyReturnsOnCall(i int, result1 []*multi.TypeTwo, result2 error) {
	fake.providerStubOnlyMutex.Lock()
	defer fake.providerStubOnlyMutex.Unlock()
	fake.ProviderStubOnlyStub = nil
	if fake.providerStubOnlyReturnsOnCall == nil {
		fake.providerStubOnlyReturnsOnCall = make(map[int]struct {
			result1 []*multi.TypeTwo
			result2 error
		})
	}
	fake.providerStubOnlyReturnsOnCall[i] = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) Shutdown(arg1 context.Context) error {
	fake.shutdownMutex.Lock()
	ret, specificReturn := fake.shutdownReturnsOnCall[len(fake.shutdownArgsForCall)]
	fake.shutdownArgsForCall = append(fake.shutdownArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Shutdown", []interface{}{arg1})
	fake.shutdownMutex.Unlock()
	if fake.ShutdownStub != nil {
		return fake.ShutdownStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.shutdownReturns
	return fakeReturns.result1
}

func (fake *FakeTypeTwoCollection) ShutdownCallCount() int {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	return len(fake.shutdownArgsForCall)
}

func (fake *FakeTypeTwoCollection) ShutdownCalls(stub func(context.Context) error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = stub
}

func (fake *FakeTypeTwoCollection) ShutdownArgsForCall(i int) context.Context {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	argsForCall := fake.shutdownArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTypeTwoCollection) ShutdownReturns(result1 error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	fake.shutdownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTypeTwoCollection) ShutdownReturnsOnCall(i int, result1 error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	if fake.shutdownReturnsOnCall == nil {
		fake.shutdownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.shutdownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTypeTwoCollection) String() string {
	fake.stringMutex.Lock()
	ret, specificReturn := fake.stringReturnsOnCall[len(fake.stringArgsForCall)]
	fake.stringArgsForCall = append(fake.stringArgsForCall, struct {
	}{})
	fake.recordInvocation("String", []interface{}{})
	fake.stringMutex.Unlock()
	if fake.StringStub != nil {
		return fake.StringStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.stringReturns
	return fakeReturns.result1
}

func (fake *FakeTypeTwoCollection) StringCallCount() int {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	return len(fake.stringArgsForCall)
}

func (fake *FakeTypeTwoCollection) StringCalls(stub func() string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = stub
}

func (fake *FakeTypeTwoCollection) StringReturns(result1 string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	fake.stringReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTypeTwoCollection) StringReturnsOnCall(i int, result1 string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	if fake.stringReturnsOnCall == nil {
		fake.stringReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.stringReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTypeTwoCollection) Update(arg1 context.Context, arg2 *multi.TypeTwo, arg3 *dal_multi.TypeTwoFieldValues) (*multi.TypeTwo, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 *multi.TypeTwo
		arg3 *dal_multi.TypeTwoFieldValues
	}{arg1, arg2, arg3})
	fake.recordInvocation("Update", []interface{}{arg1, arg2, arg3})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypeTwoCollection) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeTypeTwoCollection) UpdateCalls(stub func(context.Context, *multi.TypeTwo, *dal_multi.TypeTwoFieldValues) (*multi.TypeTwo, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeTypeTwoCollection) UpdateArgsForCall(i int) (context.Context, *multi.TypeTwo, *dal_multi.TypeTwoFieldValues) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTypeTwoCollection) UpdateReturns(result1 *multi.TypeTwo, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) UpdateReturnsOnCall(i int, result1 *multi.TypeTwo, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *multi.TypeTwo
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) Upsert(arg1 context.Context, arg2 *multi.TypeTwo) (*multi.TypeTwo, error) {
	fake.upsertMutex.Lock()
	ret, specificReturn := fake.upsertReturnsOnCall[len(fake.upsertArgsForCall)]
	fake.upsertArgsForCall = append(fake.upsertArgsForCall, struct {
		arg1 context.Context
		arg2 *multi.TypeTwo
	}{arg1, arg2})
	fake.recordInvocation("Upsert", []interface{}{arg1, arg2})
	fake.upsertMutex.Unlock()
	if fake.UpsertStub != nil {
		return fake.UpsertStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.upsertReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypeTwoCollection) UpsertCallCount() int {
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	return len(fake.upsertArgsForCall)
}

func (fake *FakeTypeTwoCollection) UpsertCalls(stub func(context.Context, *multi.TypeTwo) (*multi.TypeTwo, error)) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = stub
}

func (fake *FakeTypeTwoCollection) UpsertArgsForCall(i int) (context.Context, *multi.TypeTwo) {
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	argsForCall := fake.upsertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTypeTwoCollection) UpsertReturns(result1 *multi.TypeTwo, result2 error) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = nil
	fake.upsertReturns = struct {
		result1 *multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) UpsertReturnsOnCall(i int, result1 *multi.TypeTwo, result2 error) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = nil
	if fake.upsertReturnsOnCall == nil {
		fake.upsertReturnsOnCall = make(map[int]struct {
			result1 *multi.TypeTwo
			result2 error
		})
	}
	fake.upsertReturnsOnCall[i] = struct {
		result1 *multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) WithComparator(arg1 context.Context, arg2 int32) ([]*multi.TypeTwo, error) {
	fake.withComparatorMutex.Lock()
	ret, specificReturn := fake.withComparatorReturnsOnCall[len(fake.withComparatorArgsForCall)]
	fake.withComparatorArgsForCall = append(fake.withComparatorArgsForCall, struct {
		arg1 context.Context
		arg2 int32
	}{arg1, arg2})
	fake.recordInvocation("WithComparator", []interface{}{arg1, arg2})
	fake.withComparatorMutex.Unlock()
	if fake.WithComparatorStub != nil {
		return fake.WithComparatorStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.withComparatorReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypeTwoCollection) WithComparatorCallCount() int {
	fake.withComparatorMutex.RLock()
	defer fake.withComparatorMutex.RUnlock()
	return len(fake.withComparatorArgsForCall)
}

func (fake *FakeTypeTwoCollection) WithComparatorCalls(stub func(context.Context, int32) ([]*multi.TypeTwo, error)) {
	fake.withComparatorMutex.Lock()
	defer fake.withComparatorMutex.Unlock()
	fake.WithComparatorStub = stub
}

func (fake *FakeTypeTwoCollection) WithComparatorArgsForCall(i int) (context.Context, int32) {
	fake.withComparatorMutex.RLock()
	defer fake.withComparatorMutex.RUnlock()
	argsForCall := fake.withComparatorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTypeTwoCollection) WithComparatorReturns(result1 []*multi.TypeTwo, result2 error) {
	fake.withComparatorMutex.Lock()
	defer fake.withComparatorMutex.Unlock()
	fake.WithComparatorStub = nil
	fake.withComparatorReturns = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) WithComparatorReturnsOnCall(i int, result1 []*multi.TypeTwo, result2 error) {
	fake.withComparatorMutex.Lock()
	defer fake.withComparatorMutex.Unlock()
	fake.WithComparatorStub = nil
	if fake.withComparatorReturnsOnCall == nil {
		fake.withComparatorReturnsOnCall = make(map[int]struct {
			result1 []*multi.TypeTwo
			result2 error
		})
	}
	fake.withComparatorReturnsOnCall[i] = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) WithDependencies(arg1 ...service.Service) {
	fake.withDependenciesMutex.Lock()
	fake.withDependenciesArgsForCall = append(fake.withDependenciesArgsForCall, struct {
		arg1 []service.Service
	}{arg1})
	fake.recordInvocation("WithDependencies", []interface{}{arg1})
	fake.withDependenciesMutex.Unlock()
	if fake.WithDependenciesStub != nil {
		fake.WithDependenciesStub(arg1...)
	}
}

func (fake *FakeTypeTwoCollection) WithDependenciesCallCount() int {
	fake.withDependenciesMutex.RLock()
	defer fake.withDependenciesMutex.RUnlock()
	return len(fake.withDependenciesArgsForCall)
}

func (fake *FakeTypeTwoCollection) WithDependenciesCalls(stub func(...service.Service)) {
	fake.withDependenciesMutex.Lock()
	defer fake.withDependenciesMutex.Unlock()
	fake.WithDependenciesStub = stub
}

func (fake *FakeTypeTwoCollection) WithDependenciesArgsForCall(i int) []service.Service {
	fake.withDependenciesMutex.RLock()
	defer fake.withDependenciesMutex.RUnlock()
	argsForCall := fake.withDependenciesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTypeTwoCollection) WithRest(arg1 context.Context, arg2 int32, arg3 int64, arg4 float32, arg5 float64) ([]*multi.TypeTwo, error) {
	fake.withRestMutex.Lock()
	ret, specificReturn := fake.withRestReturnsOnCall[len(fake.withRestArgsForCall)]
	fake.withRestArgsForCall = append(fake.withRestArgsForCall, struct {
		arg1 context.Context
		arg2 int32
		arg3 int64
		arg4 float32
		arg5 float64
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("WithRest", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.withRestMutex.Unlock()
	if fake.WithRestStub != nil {
		return fake.WithRestStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.withRestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypeTwoCollection) WithRestCallCount() int {
	fake.withRestMutex.RLock()
	defer fake.withRestMutex.RUnlock()
	return len(fake.withRestArgsForCall)
}

func (fake *FakeTypeTwoCollection) WithRestCalls(stub func(context.Context, int32, int64, float32, float64) ([]*multi.TypeTwo, error)) {
	fake.withRestMutex.Lock()
	defer fake.withRestMutex.Unlock()
	fake.WithRestStub = stub
}

func (fake *FakeTypeTwoCollection) WithRestArgsForCall(i int) (context.Context, int32, int64, float32, float64) {
	fake.withRestMutex.RLock()
	defer fake.withRestMutex.RUnlock()
	argsForCall := fake.withRestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeTypeTwoCollection) WithRestReturns(result1 []*multi.TypeTwo, result2 error) {
	fake.withRestMutex.Lock()
	defer fake.withRestMutex.Unlock()
	fake.WithRestStub = nil
	fake.withRestReturns = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) WithRestReturnsOnCall(i int, result1 []*multi.TypeTwo, result2 error) {
	fake.withRestMutex.Lock()
	defer fake.withRestMutex.Unlock()
	fake.WithRestStub = nil
	if fake.withRestReturnsOnCall == nil {
		fake.withRestReturnsOnCall = make(map[int]struct {
			result1 []*multi.TypeTwo
			result2 error
		})
	}
	fake.withRestReturnsOnCall[i] = struct {
		result1 []*multi.TypeTwo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypeTwoCollection) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	fake.dependantsMutex.RLock()
	defer fake.dependantsMutex.RUnlock()
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	fake.interfaceStubOnlyMutex.RLock()
	defer fake.interfaceStubOnlyMutex.RUnlock()
	fake.messageParamMutex.RLock()
	defer fake.messageParamMutex.RUnlock()
	fake.multipleParamMutex.RLock()
	defer fake.multipleParamMutex.RUnlock()
	fake.nameOfMutex.RLock()
	defer fake.nameOfMutex.RUnlock()
	fake.oneParamMutex.RLock()
	defer fake.oneParamMutex.RUnlock()
	fake.providerStubOnlyMutex.RLock()
	defer fake.providerStubOnlyMutex.RUnlock()
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	fake.withComparatorMutex.RLock()
	defer fake.withComparatorMutex.RUnlock()
	fake.withDependenciesMutex.RLock()
	defer fake.withDependenciesMutex.RUnlock()
	fake.withRestMutex.RLock()
	defer fake.withRestMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTypeTwoCollection) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dal_multi.TypeTwoCollection = new(FakeTypeTwoCollection)
