// Package postgres_dal_multi is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package postgres_dal_multi

import (
	bytes "bytes"
	context "context"
	sql1 "database/sql"
	fmt "fmt"
	log "log"
	strings "strings"
	sync "sync"
	template "text/template"
	time "time"

	multi "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/multi"
	dal "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/multi/dal"
	dal1 "github.com/rleszilm/genms/dal"
	sql "github.com/rleszilm/genms/sql"
	stats "go.opencensus.io/stats"
	view "go.opencensus.io/stats/view"
	tag "go.opencensus.io/tag"
)

// TypeTwoCollection is an autogenerated implementation of dal.TypeTwoCollection.
type TypeTwoCollection struct {
	dal.UnimplementedTypeTwoCollection

	db     sql.DB
	config *TypeTwoConfig

	execInsert string
	execUpsert string
	queryAll   string

	execUpdateTmpl *template.Template

	queryOneParam         string
	queryMultipleParam    string
	queryMessageParam     string
	queryWithComparator   string
	queryWithRest         string
	queryProviderStubOnly string
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *TypeTwoCollection) Initialize(_ context.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *TypeTwoCollection) Shutdown(_ context.Context) error {
	return nil
}

// NameOf returns the name of a service. This must be unique if there are multiple instances of the same
// service.
func (x *TypeTwoCollection) NameOf() string {
	return "postgres_dal_multi_" + x.config.TableName
}

// String returns a string identifier for the service.
func (x *TypeTwoCollection) String() string {
	return x.NameOf()
}

// DoInsert provides the base logic for dal.TypeTwoCollection.Insert.
// The user should use this as a base for dal.TypeTwoCollection.Insert, only having to add
// code that interprets the returned values.
func (x *TypeTwoCollection) DoInsert(ctx context.Context, arg *multi.TypeTwo) (sql1.Result, error) {
	var err error
	start := time.Now()

	ctx, _ = tag.New(ctx,
		tag.Upsert(tagQueryCollection, "type_two"),
	)

	ctx, _ = tag.New(ctx,
		tag.Upsert(tagQueryName, "insert"),
	)

	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)

		if err != nil {
			ctx, _ = tag.New(ctx,
				tag.Insert(tagQueryError, "true"),
			)
		}

		stats.Record(ctx, measureLatency.M(dur), measureInflight.M(-1))
	}()

	return x.db.ExecWithReplacements(ctx, x.execInsert, type_twoWriterFromGeneric(arg))
}

// DoUpsert provides the base logic for dal.TypeTwoCollection.Upsert.
// The user should use this as a base for dal.TypeTwoCollection.Upsert, only having to add
// code that interprets the returned values.
func (x *TypeTwoCollection) DoUpsert(ctx context.Context, arg *multi.TypeTwo) (sql1.Result, error) {
	var err error
	start := time.Now()

	ctx, _ = tag.New(ctx,
		tag.Upsert(tagQueryCollection, "type_two"),
	)

	ctx, _ = tag.New(ctx,
		tag.Upsert(tagQueryName, "upsert"),
	)

	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)

		if err != nil {
			ctx, _ = tag.New(ctx,
				tag.Insert(tagQueryError, "true"),
			)
		}

		stats.Record(ctx, measureLatency.M(dur), measureInflight.M(-1))
	}()

	return x.db.ExecWithReplacements(ctx, x.execUpsert, type_twoWriterFromGeneric(arg))
}

// DoUpdate provides the base logic for dal.TypeTwoCollection.Upsert.
// The user should use this as a base for dal.TypeTwoCollection.Upsert, only having to add
// code that interprets the returned values.
func (x *TypeTwoCollection) DoUpdate(ctx context.Context, fvs *dal.TypeTwoFieldValues, clause string) (sql1.Result, error) {
	var err error
	start := time.Now()

	ctx, _ = tag.New(ctx,
		tag.Upsert(tagQueryCollection, "type_two"),
	)

	ctx, _ = tag.New(ctx,
		tag.Upsert(tagQueryName, "update"),
	)

	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)

		if err != nil {
			ctx, _ = tag.New(ctx,
				tag.Insert(tagQueryError, "true"),
			)
		}

		stats.Record(ctx, measureLatency.M(dur), measureInflight.M(-1))
	}()

	updates := []string{}

	if fvs.ScalarInt32 != nil {
		updates = append(updates, "scalar_int32 = :scalar_int32")
	}

	if fvs.ScalarInt64 != nil {
		updates = append(updates, "scalar_int64 = :scalar_int64")
	}

	if fvs.ScalarFloat32 != nil {
		updates = append(updates, "scalar_float32 = :scalar_float32")
	}

	if fvs.ScalarFloat64 != nil {
		updates = append(updates, "scalar_float64 = :scalar_float64")
	}

	if fvs.ScalarString != nil {
		updates = append(updates, "scalar_string = :scalar_string")
	}

	if fvs.ScalarBool != nil {
		updates = append(updates, "scalar_bool = :scalar_bool")
	}

	if fvs.ScalarEnum != nil {
		updates = append(updates, "scalar_enum = :scalar_enum")
	}

	if fvs.ObjMessage != nil {
		updates = append(updates, "obj_message = :obj_message")
	}

	if fvs.Renamed != nil {
		updates = append(updates, "aliased = :aliased")
	}

	if fvs.RenamedPostgres != nil {
		updates = append(updates, "aliased_postgres = :aliased_postgres")
	}

	if fvs.IgnoredRest != nil {
		updates = append(updates, "ignored_rest = :ignored_rest")
	}

	if fvs.RenamedRest != nil {
		updates = append(updates, "renamed_rest = :renamed_rest")
	}
	buf := &bytes.Buffer{}
	if err := x.execUpdateTmpl.Execute(buf, map[string]interface{}{
		"clause":  clause,
		"table":   x.config.TableName,
		"updates": strings.Join(updates, ", "),
	}); err != nil {
		return nil, err
	}

	return x.db.ExecWithReplacements(ctx, string(buf.Bytes()), type_twoFieldValuesFromGeneric(fvs))
}

// All implements dal.TypeTwoCollection.All
func (x *TypeTwoCollection) All(ctx context.Context) ([]*multi.TypeTwo, error) {
	return x.find(ctx, "all", x.queryAll, map[string]interface{}{})
}

// Filter implements dal.TypeTwoCollection.Filter
func (x *TypeTwoCollection) Filter(ctx context.Context, fvs *dal.TypeTwoFieldValues) ([]*multi.TypeTwo, error) {
	query := "SELECT scalar_int32, scalar_int64, scalar_float32, scalar_float64, scalar_string, scalar_bool, scalar_enum, obj_message, ignored, aliased, ignored_postgres, aliased_postgres, ignored_rest, renamed_rest FROM " + x.config.TableName

	fields := []string{}
	if fvs.ScalarInt32 != nil {
		fields = append(fields, "scalar_int32 = :scalar_int32")
	}
	if fvs.ScalarInt64 != nil {
		fields = append(fields, "scalar_int64 = :scalar_int64")
	}
	if fvs.ScalarFloat32 != nil {
		fields = append(fields, "scalar_float32 = :scalar_float32")
	}
	if fvs.ScalarFloat64 != nil {
		fields = append(fields, "scalar_float64 = :scalar_float64")
	}
	if fvs.ScalarString != nil {
		fields = append(fields, "scalar_string = :scalar_string")
	}
	if fvs.ScalarBool != nil {
		fields = append(fields, "scalar_bool = :scalar_bool")
	}
	if fvs.ScalarEnum != nil {
		fields = append(fields, "scalar_enum = :scalar_enum")
	}
	if fvs.ObjMessage != nil {
		fields = append(fields, "obj_message = :obj_message")
	}

	if fvs.Renamed != nil {
		fields = append(fields, "aliased = :aliased")
	}

	if fvs.RenamedPostgres != nil {
		fields = append(fields, "aliased_postgres = :aliased_postgres")
	}
	if fvs.IgnoredRest != nil {
		fields = append(fields, "ignored_rest = :ignored_rest")
	}
	if fvs.RenamedRest != nil {
		fields = append(fields, "renamed_rest = :renamed_rest")
	}
	if len(fields) > 0 {
		query = fmt.Sprintf("%s WHERE %s", query, strings.Join(fields, " AND "))
	}

	return x.find(ctx, "filter", query, type_twoFieldValuesFromGeneric(fvs))
}

func (x *TypeTwoCollection) find(ctx context.Context, label string, query string, fvs interface{}) ([]*multi.TypeTwo, error) {
	var err error
	start := time.Now()

	ctx, _ = tag.New(ctx,
		tag.Upsert(tagQueryCollection, "type_two"),
	)

	ctx, _ = tag.New(ctx,
		tag.Upsert(tagQueryName, label),
	)

	stats.Record(ctx, measureInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)

		if err != nil {
			ctx, _ = tag.New(ctx,
				tag.Upsert(tagQueryError, "true"),
			)
		}

		stats.Record(ctx, measureLatency.M(dur), measureInflight.M(-1))
	}()

	rows, err := x.db.QueryWithReplacements(ctx, query, fvs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	TypeTwos := []*multi.TypeTwo{}
	for rows.Next() {
		obj := &TypeTwoScanner{}
		if err = rows.StructScan(obj); err != nil {
			return nil, err
		}
		TypeTwos = append(TypeTwos, obj.TypeTwo())
	}
	return TypeTwos, nil
}

// OneParam implements dal.TypeTwoCollection.OneParam
func (x *TypeTwoCollection) OneParam(ctx context.Context, scalar_int32 int32) ([]*multi.TypeTwo, error) {
	fvs := map[string]interface{}{"scalar_int32": &scalar_int32}
	return x.find(ctx, "one_param", x.queryOneParam, fvs)
}

// MultipleParam implements dal.TypeTwoCollection.MultipleParam
func (x *TypeTwoCollection) MultipleParam(ctx context.Context, scalar_int32 int32, scalar_int64 int64, scalar_float32 float32) ([]*multi.TypeTwo, error) {
	fvs := map[string]interface{}{"scalar_int32": &scalar_int32, "scalar_int64": &scalar_int64, "scalar_float32": &scalar_float32}
	return x.find(ctx, "multiple_param", x.queryMultipleParam, fvs)
}

// MessageParam implements dal.TypeTwoCollection.MessageParam
func (x *TypeTwoCollection) MessageParam(ctx context.Context, obj_message *multi.TypeTwo_Message) ([]*multi.TypeTwo, error) {
	fvs := map[string]interface{}{"obj_message": obj_message}
	return x.find(ctx, "message_param", x.queryMessageParam, fvs)
}

// WithComparator implements dal.TypeTwoCollection.WithComparator
func (x *TypeTwoCollection) WithComparator(ctx context.Context, scalar_int32 int32) ([]*multi.TypeTwo, error) {
	fvs := map[string]interface{}{"scalar_int32": &scalar_int32}
	return x.find(ctx, "with_comparator", x.queryWithComparator, fvs)
}

// WithRest implements dal.TypeTwoCollection.WithRest
func (x *TypeTwoCollection) WithRest(ctx context.Context, scalar_int32 int32, scalar_int64 int64, scalar_float32 float32, scalar_float64 float64) ([]*multi.TypeTwo, error) {
	fvs := map[string]interface{}{"scalar_int32": &scalar_int32, "scalar_int64": &scalar_int64, "scalar_float32": &scalar_float32, "scalar_float64": &scalar_float64}
	return x.find(ctx, "with_rest", x.queryWithRest, fvs)
}

// ProviderStubOnly implements dal.TypeTwoCollection.ProviderStubOnly
func (x *TypeTwoCollection) ProviderStubOnly(ctx context.Context) ([]*multi.TypeTwo, error) {
	fvs := map[string]interface{}{}
	return x.find(ctx, "provider_stub_only", x.queryProviderStubOnly, fvs)
}

// NewTypeTwoCollection returns a new TypeTwoCollection.
func NewTypeTwoCollection(db sql.DB, queries TypeTwoQueryTemplateProvider, config *TypeTwoConfig) (*TypeTwoCollection, error) {
	registerTypeTwoMetricsOnce.Do(registerTypeTwoMetrics)

	coll := &TypeTwoCollection{
		db:     db,
		config: config,
	}

	queryReplacements := map[string]string{
		"table":       config.TableName,
		"fields":      "scalar_int32, scalar_int64, scalar_float32, scalar_float64, scalar_string, scalar_bool, scalar_enum, obj_message, ignored, aliased, ignored_postgres, aliased_postgres, ignored_rest, renamed_rest",
		"writeFields": ":scalar_int32, :scalar_int64, :scalar_float32, :scalar_float64, :scalar_string, :scalar_bool, :scalar_enum, :obj_message, :ignored, :aliased, :ignored_postgres, :aliased_postgres, :ignored_rest, :renamed_rest",
	}

	// generate Insert exec
	execInsert, err := dal1.RenderQuery("dal.TypeTwo-exec-insert", queries.Insert(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.execInsert = execInsert

	// generate Upsert exec
	execUpsert, err := dal1.RenderQuery("dal.TypeTwo-exec-upsert", queries.Upsert(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.execUpsert = execUpsert

	execUpdateTmpl, err := template.New("dal.TypeTwo-exec-update").
		Funcs(template.FuncMap{}).
		Parse(queries.Update())

	if err != nil {
		return nil, err
	}
	coll.execUpdateTmpl = execUpdateTmpl

	// generate All query
	queryAll, err := dal1.RenderQuery("dal.TypeTwo-query-all", queries.All(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryAll = queryAll

	// generate OneParam query
	queryOneParam, err := dal1.RenderQuery("dal.TypeTwo-query-one_param", queries.OneParam(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryOneParam = queryOneParam

	// generate MultipleParam query
	queryMultipleParam, err := dal1.RenderQuery("dal.TypeTwo-query-multiple_param", queries.MultipleParam(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryMultipleParam = queryMultipleParam

	// generate MessageParam query
	queryMessageParam, err := dal1.RenderQuery("dal.TypeTwo-query-message_param", queries.MessageParam(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryMessageParam = queryMessageParam

	// generate WithComparator query
	queryWithComparator, err := dal1.RenderQuery("dal.TypeTwo-query-with_comparator", queries.WithComparator(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryWithComparator = queryWithComparator

	// generate WithRest query
	queryWithRest, err := dal1.RenderQuery("dal.TypeTwo-query-with_rest", queries.WithRest(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryWithRest = queryWithRest

	// generate ProviderStubOnly query
	queryProviderStubOnly, err := dal1.RenderQuery("dal.TypeTwo-query-provider_stub_only", queries.ProviderStubOnly(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryProviderStubOnly = queryProviderStubOnly

	return coll, nil
}

// TypeTwoFieldValues is an autogenerated struct that is used in generic TypeTwo queries.
type TypeTwoFieldValues struct {
	ScalarInt32   *int32                 `db:"scalar_int32"`
	ScalarInt64   *int64                 `db:"scalar_int64"`
	ScalarFloat32 *float32               `db:"scalar_float32"`
	ScalarFloat64 *float64               `db:"scalar_float64"`
	ScalarString  *string                `db:"scalar_string"`
	ScalarBool    *bool                  `db:"scalar_bool"`
	ScalarEnum    *multi.TypeTwo_Enum    `db:"scalar_enum"`
	ObjMessage    *multi.TypeTwo_Message `db:"obj_message"`

	Renamed *string `db:"aliased"`

	RenamedPostgres *string `db:"aliased_postgres"`
	IgnoredRest     *string `db:"ignored_rest"`
	RenamedRest     *string `db:"renamed_rest"`
}

func type_twoFieldValuesFromGeneric(y *dal.TypeTwoFieldValues) *TypeTwoFieldValues {
	f := &TypeTwoFieldValues{}
	if y.ScalarInt32 != nil {
		f.ScalarInt32 = y.ScalarInt32
	}
	if y.ScalarInt64 != nil {
		f.ScalarInt64 = y.ScalarInt64
	}
	if y.ScalarFloat32 != nil {
		f.ScalarFloat32 = y.ScalarFloat32
	}
	if y.ScalarFloat64 != nil {
		f.ScalarFloat64 = y.ScalarFloat64
	}
	if y.ScalarString != nil {
		f.ScalarString = y.ScalarString
	}
	if y.ScalarBool != nil {
		f.ScalarBool = y.ScalarBool
	}
	if y.ScalarEnum != nil {
		f.ScalarEnum = y.ScalarEnum
	}
	if y.ObjMessage != nil {
		f.ObjMessage = y.ObjMessage
	}

	if y.Renamed != nil {
		f.Renamed = y.Renamed
	}

	if y.RenamedPostgres != nil {
		f.RenamedPostgres = y.RenamedPostgres
	}
	if y.IgnoredRest != nil {
		f.IgnoredRest = y.IgnoredRest
	}
	if y.RenamedRest != nil {
		f.RenamedRest = y.RenamedRest
	}
	return f
}

// TypeTwoScanner is an autogenerated struct that
// is used to parse query results.
type TypeTwoScanner struct {
	ScalarInt32   sql1.NullInt32         `db:"scalar_int32"`
	ScalarInt64   sql1.NullInt64         `db:"scalar_int64"`
	ScalarFloat32 sql1.NullFloat64       `db:"scalar_float32"`
	ScalarFloat64 sql1.NullFloat64       `db:"scalar_float64"`
	ScalarString  sql1.NullString        `db:"scalar_string"`
	ScalarBool    sql1.NullBool          `db:"scalar_bool"`
	ScalarEnum    sql1.NullInt32         `db:"scalar_enum"`
	ObjMessage    *multi.TypeTwo_Message `db:"obj_message"`

	Renamed sql1.NullString `db:"aliased"`

	RenamedPostgres sql1.NullString `db:"aliased_postgres"`
	IgnoredRest     sql1.NullString `db:"ignored_rest"`
	RenamedRest     sql1.NullString `db:"renamed_rest"`
}

// TypeTwo returns a new multi.TypeTwo populated with scanned values.
func (x *TypeTwoScanner) TypeTwo() *multi.TypeTwo {
	y := &multi.TypeTwo{}

	if x.ScalarInt32.Valid {
		y.ScalarInt32 = x.ScalarInt32.Int32
	}
	if x.ScalarInt64.Valid {
		y.ScalarInt64 = x.ScalarInt64.Int64
	}
	if x.ScalarFloat32.Valid {
		y.ScalarFloat32 = float32(x.ScalarFloat32.Float64)
	}
	if x.ScalarFloat64.Valid {
		y.ScalarFloat64 = x.ScalarFloat64.Float64
	}
	if x.ScalarString.Valid {
		y.ScalarString = x.ScalarString.String
	}
	if x.ScalarBool.Valid {
		y.ScalarBool = x.ScalarBool.Bool
	}
	if x.ScalarEnum.Valid {
		y.ScalarEnum = multi.TypeTwo_Enum(x.ScalarEnum.Int32)
	}
	y.ObjMessage = x.ObjMessage

	if x.Renamed.Valid {
		y.Renamed = x.Renamed.String
	}

	if x.RenamedPostgres.Valid {
		y.RenamedPostgres = x.RenamedPostgres.String
	}
	if x.IgnoredRest.Valid {
		y.IgnoredRest = x.IgnoredRest.String
	}
	if x.RenamedRest.Valid {
		y.RenamedRest = x.RenamedRest.String
	}
	return y
}

// TypeTwoWriter is an autogenerated struct that is used to supply values to write queries.
type TypeTwoWriter struct {
	ScalarInt32   int32                  `db:"scalar_int32"`
	ScalarInt64   int64                  `db:"scalar_int64"`
	ScalarFloat32 float32                `db:"scalar_float32"`
	ScalarFloat64 float64                `db:"scalar_float64"`
	ScalarString  string                 `db:"scalar_string"`
	ScalarBool    bool                   `db:"scalar_bool"`
	ScalarEnum    multi.TypeTwo_Enum     `db:"scalar_enum"`
	ObjMessage    *multi.TypeTwo_Message `db:"obj_message"`

	Renamed string `db:"aliased"`

	RenamedPostgres string `db:"aliased_postgres"`
	IgnoredRest     string `db:"ignored_rest"`
	RenamedRest     string `db:"renamed_rest"`
}

func type_twoWriterFromGeneric(y *multi.TypeTwo) *TypeTwoWriter {
	x := &TypeTwoWriter{}
	x.ScalarInt32 = y.ScalarInt32
	x.ScalarInt64 = y.ScalarInt64
	x.ScalarFloat32 = y.ScalarFloat32
	x.ScalarFloat64 = y.ScalarFloat64
	x.ScalarString = y.ScalarString
	x.ScalarBool = y.ScalarBool
	x.ScalarEnum = y.ScalarEnum
	x.ObjMessage = y.ObjMessage

	x.Renamed = y.Renamed

	x.RenamedPostgres = y.RenamedPostgres
	x.IgnoredRest = y.IgnoredRest
	x.RenamedRest = y.RenamedRest
	return x
}

// TypeTwoConfig is a struct that can be used to configure a TypeTwoCollection
type TypeTwoConfig struct {
	TableName string `envconfig:"table"`
}

// TypeTwoQueryTemplateProvider is an interface that returns the query templated that should be executed
// to generate the queries that the collection will use.
//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 . TypeTwoQueryTemplateProvider
type TypeTwoQueryTemplateProvider interface {
	Insert() string
	Upsert() string
	Update() string
	All() string
	OneParam() string
	MultipleParam() string
	MessageParam() string
	WithComparator() string
	WithRest() string
	ProviderStubOnly() string
}

// TypeTwoQueries provides auto-generated queries when possible. This is not gauranteed to be a complete
// implementation of the interface. This should be used as a base for the actual query provider used.
type TypeTwoQueries struct {
}

// Insert implements TypeTwoQueryTemplateProvider.Insert.
func (x *TypeTwoQueries) Insert() string {
	return `INSERT INTO {{ .table }}({{ .fields }}) VALUES({{ .writeFields }});`
}

// Upsert implements TypeTwoQueryTemplateProvider.Upsert.
func (x *TypeTwoQueries) Upsert() string {
	return `INSERT INTO {{ .table }}({{ .fields }}) VALUES({{ .writeFields }});`
}

// Update implements TypeTwoQueryTemplateProvider.Update.
func (x *TypeTwoQueries) Update() string {
	return `UPDATE {{ .table }} SET {{ .updates }}{{ if .clause }} WHERE {{ .clause }}{{ end }};`
}

// All implements TypeTwoQueryTemplateProvider.All.
func (x *TypeTwoQueries) All() string {
	return `SELECT {{ .fields }} FROM {{ .table }};`
}

//OneParamimplements TypeTwoQueryTemplateProvider.OneParam.
func (x *TypeTwoQueries) OneParam() string {
	return `SELECT {{ .fields }} FROM {{ .table }} WHERE
			1 = 1 AND
				scalar_int32 = :scalar_int32;`
}

//MultipleParamimplements TypeTwoQueryTemplateProvider.MultipleParam.
func (x *TypeTwoQueries) MultipleParam() string {
	return `SELECT {{ .fields }} FROM {{ .table }} WHERE
			1 = 1 AND
				scalar_int32 = :scalar_int32 AND
				scalar_int64 = :scalar_int64 AND
				scalar_float32 = :scalar_float32;`
}

//MessageParamimplements TypeTwoQueryTemplateProvider.MessageParam.
func (x *TypeTwoQueries) MessageParam() string {
	return `SELECT {{ .fields }} FROM {{ .table }} WHERE
			1 = 1 AND
				obj_message = :obj_message;`
}

//WithComparatorimplements TypeTwoQueryTemplateProvider.WithComparator.
func (x *TypeTwoQueries) WithComparator() string {
	return `SELECT {{ .fields }} FROM {{ .table }} WHERE
			1 = 1 AND
				scalar_int32 > :scalar_int32;`
}

//WithRestimplements TypeTwoQueryTemplateProvider.WithRest.
func (x *TypeTwoQueries) WithRest() string {
	return `SELECT {{ .fields }} FROM {{ .table }} WHERE
			1 = 1 AND
				scalar_int32 = :scalar_int32 AND
				scalar_int64 = :scalar_int64 AND
				scalar_float32 = :scalar_float32 AND
				scalar_float64 = :scalar_float64;`
}

// define metrics
var (
	tagQueryName       = tag.MustNewKey("dal_postgres_query")
	tagQueryCollection = tag.MustNewKey("dal_postgres_collection")
	tagQueryError      = tag.MustNewKey("dal_postgres_error")

	measureLatency  = stats.Float64("dal_postgres_latency", "Latency of TypeTwo queries", stats.UnitMilliseconds)
	measureInflight = stats.Int64("dal_postgres_inflight", "Count of TypeTwo queries in flight", stats.UnitDimensionless)

	registerTypeTwoMetricsOnce sync.Once
)

func registerTypeTwoMetrics() {
	views := []*view.View{
		{
			Name:        "dal_postgres_latency",
			Measure:     measureLatency,
			Description: "The distribution of the query latencies",
			TagKeys:     []tag.Key{tagQueryName, tagQueryCollection, tagQueryError},
			Aggregation: view.Distribution(0, 25, 100, 200, 400, 800, 10000),
		},
		{
			Name:        "dal_postgres_inflight",
			Measure:     measureInflight,
			Description: "The number of queries being processed",
			TagKeys:     []tag.Key{tagQueryName, tagQueryCollection},
			Aggregation: view.Sum(),
		},
	}

	if err := view.Register(views...); err != nil {
		log.Fatal("Cannot register metrics:", err)
	}
}
