// Code generated by counterfeiter. DO NOT EDIT.
package dalfakes

import (
	"context"
	"sync"

	"github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/single"
	dal_single "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/single/dal"
	"github.com/rleszilm/genms/service"
)

type FakeSingleCollection struct {
	AllStub        func(context.Context) ([]*single.Single, error)
	allMutex       sync.RWMutex
	allArgsForCall []struct {
		arg1 context.Context
	}
	allReturns struct {
		result1 []*single.Single
		result2 error
	}
	allReturnsOnCall map[int]struct {
		result1 []*single.Single
		result2 error
	}
	ByIdStub        func(context.Context, string) ([]*single.Single, error)
	byIdMutex       sync.RWMutex
	byIdArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	byIdReturns struct {
		result1 []*single.Single
		result2 error
	}
	byIdReturnsOnCall map[int]struct {
		result1 []*single.Single
		result2 error
	}
	DependantsStub        func() service.Services
	dependantsMutex       sync.RWMutex
	dependantsArgsForCall []struct {
	}
	dependantsReturns struct {
		result1 service.Services
	}
	dependantsReturnsOnCall map[int]struct {
		result1 service.Services
	}
	FilterStub        func(context.Context, *dal_single.SingleFieldValues) ([]*single.Single, error)
	filterMutex       sync.RWMutex
	filterArgsForCall []struct {
		arg1 context.Context
		arg2 *dal_single.SingleFieldValues
	}
	filterReturns struct {
		result1 []*single.Single
		result2 error
	}
	filterReturnsOnCall map[int]struct {
		result1 []*single.Single
		result2 error
	}
	InitializeStub        func(context.Context) error
	initializeMutex       sync.RWMutex
	initializeArgsForCall []struct {
		arg1 context.Context
	}
	initializeReturns struct {
		result1 error
	}
	initializeReturnsOnCall map[int]struct {
		result1 error
	}
	InsertStub        func(context.Context, *single.Single) (*single.Single, error)
	insertMutex       sync.RWMutex
	insertArgsForCall []struct {
		arg1 context.Context
		arg2 *single.Single
	}
	insertReturns struct {
		result1 *single.Single
		result2 error
	}
	insertReturnsOnCall map[int]struct {
		result1 *single.Single
		result2 error
	}
	InterfaceStubOnlyStub        func(context.Context) ([]*single.Single, error)
	interfaceStubOnlyMutex       sync.RWMutex
	interfaceStubOnlyArgsForCall []struct {
		arg1 context.Context
	}
	interfaceStubOnlyReturns struct {
		result1 []*single.Single
		result2 error
	}
	interfaceStubOnlyReturnsOnCall map[int]struct {
		result1 []*single.Single
		result2 error
	}
	MessageParamStub        func(context.Context, *single.Single_Message) ([]*single.Single, error)
	messageParamMutex       sync.RWMutex
	messageParamArgsForCall []struct {
		arg1 context.Context
		arg2 *single.Single_Message
	}
	messageParamReturns struct {
		result1 []*single.Single
		result2 error
	}
	messageParamReturnsOnCall map[int]struct {
		result1 []*single.Single
		result2 error
	}
	MultipleParamStub        func(context.Context, int32, int64, float32) ([]*single.Single, error)
	multipleParamMutex       sync.RWMutex
	multipleParamArgsForCall []struct {
		arg1 context.Context
		arg2 int32
		arg3 int64
		arg4 float32
	}
	multipleParamReturns struct {
		result1 []*single.Single
		result2 error
	}
	multipleParamReturnsOnCall map[int]struct {
		result1 []*single.Single
		result2 error
	}
	NameOfStub        func() string
	nameOfMutex       sync.RWMutex
	nameOfArgsForCall []struct {
	}
	nameOfReturns struct {
		result1 string
	}
	nameOfReturnsOnCall map[int]struct {
		result1 string
	}
	NonFieldOnlyStub        func(context.Context, string) ([]*single.Single, error)
	nonFieldOnlyMutex       sync.RWMutex
	nonFieldOnlyArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	nonFieldOnlyReturns struct {
		result1 []*single.Single
		result2 error
	}
	nonFieldOnlyReturnsOnCall map[int]struct {
		result1 []*single.Single
		result2 error
	}
	OneParamStub        func(context.Context, int32) ([]*single.Single, error)
	oneParamMutex       sync.RWMutex
	oneParamArgsForCall []struct {
		arg1 context.Context
		arg2 int32
	}
	oneParamReturns struct {
		result1 []*single.Single
		result2 error
	}
	oneParamReturnsOnCall map[int]struct {
		result1 []*single.Single
		result2 error
	}
	ProviderStubOnlyStub        func(context.Context) ([]*single.Single, error)
	providerStubOnlyMutex       sync.RWMutex
	providerStubOnlyArgsForCall []struct {
		arg1 context.Context
	}
	providerStubOnlyReturns struct {
		result1 []*single.Single
		result2 error
	}
	providerStubOnlyReturnsOnCall map[int]struct {
		result1 []*single.Single
		result2 error
	}
	ShutdownStub        func(context.Context) error
	shutdownMutex       sync.RWMutex
	shutdownArgsForCall []struct {
		arg1 context.Context
	}
	shutdownReturns struct {
		result1 error
	}
	shutdownReturnsOnCall map[int]struct {
		result1 error
	}
	StringStub        func() string
	stringMutex       sync.RWMutex
	stringArgsForCall []struct {
	}
	stringReturns struct {
		result1 string
	}
	stringReturnsOnCall map[int]struct {
		result1 string
	}
	UpdateStub        func(context.Context, *single.Single, *dal_single.SingleFieldValues) (*single.Single, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 *single.Single
		arg3 *dal_single.SingleFieldValues
	}
	updateReturns struct {
		result1 *single.Single
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *single.Single
		result2 error
	}
	UpsertStub        func(context.Context, *single.Single) (*single.Single, error)
	upsertMutex       sync.RWMutex
	upsertArgsForCall []struct {
		arg1 context.Context
		arg2 *single.Single
	}
	upsertReturns struct {
		result1 *single.Single
		result2 error
	}
	upsertReturnsOnCall map[int]struct {
		result1 *single.Single
		result2 error
	}
	WithComparatorStub        func(context.Context, int32) ([]*single.Single, error)
	withComparatorMutex       sync.RWMutex
	withComparatorArgsForCall []struct {
		arg1 context.Context
		arg2 int32
	}
	withComparatorReturns struct {
		result1 []*single.Single
		result2 error
	}
	withComparatorReturnsOnCall map[int]struct {
		result1 []*single.Single
		result2 error
	}
	WithDependenciesStub        func(...service.Service)
	withDependenciesMutex       sync.RWMutex
	withDependenciesArgsForCall []struct {
		arg1 []service.Service
	}
	WithRestStub        func(context.Context, int32, int64, float32, float64) ([]*single.Single, error)
	withRestMutex       sync.RWMutex
	withRestArgsForCall []struct {
		arg1 context.Context
		arg2 int32
		arg3 int64
		arg4 float32
		arg5 float64
	}
	withRestReturns struct {
		result1 []*single.Single
		result2 error
	}
	withRestReturnsOnCall map[int]struct {
		result1 []*single.Single
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSingleCollection) All(arg1 context.Context) ([]*single.Single, error) {
	fake.allMutex.Lock()
	ret, specificReturn := fake.allReturnsOnCall[len(fake.allArgsForCall)]
	fake.allArgsForCall = append(fake.allArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("All", []interface{}{arg1})
	fake.allMutex.Unlock()
	if fake.AllStub != nil {
		return fake.AllStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.allReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSingleCollection) AllCallCount() int {
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	return len(fake.allArgsForCall)
}

func (fake *FakeSingleCollection) AllCalls(stub func(context.Context) ([]*single.Single, error)) {
	fake.allMutex.Lock()
	defer fake.allMutex.Unlock()
	fake.AllStub = stub
}

func (fake *FakeSingleCollection) AllArgsForCall(i int) context.Context {
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	argsForCall := fake.allArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSingleCollection) AllReturns(result1 []*single.Single, result2 error) {
	fake.allMutex.Lock()
	defer fake.allMutex.Unlock()
	fake.AllStub = nil
	fake.allReturns = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) AllReturnsOnCall(i int, result1 []*single.Single, result2 error) {
	fake.allMutex.Lock()
	defer fake.allMutex.Unlock()
	fake.AllStub = nil
	if fake.allReturnsOnCall == nil {
		fake.allReturnsOnCall = make(map[int]struct {
			result1 []*single.Single
			result2 error
		})
	}
	fake.allReturnsOnCall[i] = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) ById(arg1 context.Context, arg2 string) ([]*single.Single, error) {
	fake.byIdMutex.Lock()
	ret, specificReturn := fake.byIdReturnsOnCall[len(fake.byIdArgsForCall)]
	fake.byIdArgsForCall = append(fake.byIdArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ById", []interface{}{arg1, arg2})
	fake.byIdMutex.Unlock()
	if fake.ByIdStub != nil {
		return fake.ByIdStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.byIdReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSingleCollection) ByIdCallCount() int {
	fake.byIdMutex.RLock()
	defer fake.byIdMutex.RUnlock()
	return len(fake.byIdArgsForCall)
}

func (fake *FakeSingleCollection) ByIdCalls(stub func(context.Context, string) ([]*single.Single, error)) {
	fake.byIdMutex.Lock()
	defer fake.byIdMutex.Unlock()
	fake.ByIdStub = stub
}

func (fake *FakeSingleCollection) ByIdArgsForCall(i int) (context.Context, string) {
	fake.byIdMutex.RLock()
	defer fake.byIdMutex.RUnlock()
	argsForCall := fake.byIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSingleCollection) ByIdReturns(result1 []*single.Single, result2 error) {
	fake.byIdMutex.Lock()
	defer fake.byIdMutex.Unlock()
	fake.ByIdStub = nil
	fake.byIdReturns = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) ByIdReturnsOnCall(i int, result1 []*single.Single, result2 error) {
	fake.byIdMutex.Lock()
	defer fake.byIdMutex.Unlock()
	fake.ByIdStub = nil
	if fake.byIdReturnsOnCall == nil {
		fake.byIdReturnsOnCall = make(map[int]struct {
			result1 []*single.Single
			result2 error
		})
	}
	fake.byIdReturnsOnCall[i] = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) Dependants() service.Services {
	fake.dependantsMutex.Lock()
	ret, specificReturn := fake.dependantsReturnsOnCall[len(fake.dependantsArgsForCall)]
	fake.dependantsArgsForCall = append(fake.dependantsArgsForCall, struct {
	}{})
	fake.recordInvocation("Dependants", []interface{}{})
	fake.dependantsMutex.Unlock()
	if fake.DependantsStub != nil {
		return fake.DependantsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.dependantsReturns
	return fakeReturns.result1
}

func (fake *FakeSingleCollection) DependantsCallCount() int {
	fake.dependantsMutex.RLock()
	defer fake.dependantsMutex.RUnlock()
	return len(fake.dependantsArgsForCall)
}

func (fake *FakeSingleCollection) DependantsCalls(stub func() service.Services) {
	fake.dependantsMutex.Lock()
	defer fake.dependantsMutex.Unlock()
	fake.DependantsStub = stub
}

func (fake *FakeSingleCollection) DependantsReturns(result1 service.Services) {
	fake.dependantsMutex.Lock()
	defer fake.dependantsMutex.Unlock()
	fake.DependantsStub = nil
	fake.dependantsReturns = struct {
		result1 service.Services
	}{result1}
}

func (fake *FakeSingleCollection) DependantsReturnsOnCall(i int, result1 service.Services) {
	fake.dependantsMutex.Lock()
	defer fake.dependantsMutex.Unlock()
	fake.DependantsStub = nil
	if fake.dependantsReturnsOnCall == nil {
		fake.dependantsReturnsOnCall = make(map[int]struct {
			result1 service.Services
		})
	}
	fake.dependantsReturnsOnCall[i] = struct {
		result1 service.Services
	}{result1}
}

func (fake *FakeSingleCollection) Filter(arg1 context.Context, arg2 *dal_single.SingleFieldValues) ([]*single.Single, error) {
	fake.filterMutex.Lock()
	ret, specificReturn := fake.filterReturnsOnCall[len(fake.filterArgsForCall)]
	fake.filterArgsForCall = append(fake.filterArgsForCall, struct {
		arg1 context.Context
		arg2 *dal_single.SingleFieldValues
	}{arg1, arg2})
	fake.recordInvocation("Filter", []interface{}{arg1, arg2})
	fake.filterMutex.Unlock()
	if fake.FilterStub != nil {
		return fake.FilterStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.filterReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSingleCollection) FilterCallCount() int {
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	return len(fake.filterArgsForCall)
}

func (fake *FakeSingleCollection) FilterCalls(stub func(context.Context, *dal_single.SingleFieldValues) ([]*single.Single, error)) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = stub
}

func (fake *FakeSingleCollection) FilterArgsForCall(i int) (context.Context, *dal_single.SingleFieldValues) {
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	argsForCall := fake.filterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSingleCollection) FilterReturns(result1 []*single.Single, result2 error) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = nil
	fake.filterReturns = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) FilterReturnsOnCall(i int, result1 []*single.Single, result2 error) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = nil
	if fake.filterReturnsOnCall == nil {
		fake.filterReturnsOnCall = make(map[int]struct {
			result1 []*single.Single
			result2 error
		})
	}
	fake.filterReturnsOnCall[i] = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) Initialize(arg1 context.Context) error {
	fake.initializeMutex.Lock()
	ret, specificReturn := fake.initializeReturnsOnCall[len(fake.initializeArgsForCall)]
	fake.initializeArgsForCall = append(fake.initializeArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Initialize", []interface{}{arg1})
	fake.initializeMutex.Unlock()
	if fake.InitializeStub != nil {
		return fake.InitializeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.initializeReturns
	return fakeReturns.result1
}

func (fake *FakeSingleCollection) InitializeCallCount() int {
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	return len(fake.initializeArgsForCall)
}

func (fake *FakeSingleCollection) InitializeCalls(stub func(context.Context) error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = stub
}

func (fake *FakeSingleCollection) InitializeArgsForCall(i int) context.Context {
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	argsForCall := fake.initializeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSingleCollection) InitializeReturns(result1 error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = nil
	fake.initializeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSingleCollection) InitializeReturnsOnCall(i int, result1 error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = nil
	if fake.initializeReturnsOnCall == nil {
		fake.initializeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initializeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSingleCollection) Insert(arg1 context.Context, arg2 *single.Single) (*single.Single, error) {
	fake.insertMutex.Lock()
	ret, specificReturn := fake.insertReturnsOnCall[len(fake.insertArgsForCall)]
	fake.insertArgsForCall = append(fake.insertArgsForCall, struct {
		arg1 context.Context
		arg2 *single.Single
	}{arg1, arg2})
	fake.recordInvocation("Insert", []interface{}{arg1, arg2})
	fake.insertMutex.Unlock()
	if fake.InsertStub != nil {
		return fake.InsertStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.insertReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSingleCollection) InsertCallCount() int {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	return len(fake.insertArgsForCall)
}

func (fake *FakeSingleCollection) InsertCalls(stub func(context.Context, *single.Single) (*single.Single, error)) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = stub
}

func (fake *FakeSingleCollection) InsertArgsForCall(i int) (context.Context, *single.Single) {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	argsForCall := fake.insertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSingleCollection) InsertReturns(result1 *single.Single, result2 error) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = nil
	fake.insertReturns = struct {
		result1 *single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) InsertReturnsOnCall(i int, result1 *single.Single, result2 error) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = nil
	if fake.insertReturnsOnCall == nil {
		fake.insertReturnsOnCall = make(map[int]struct {
			result1 *single.Single
			result2 error
		})
	}
	fake.insertReturnsOnCall[i] = struct {
		result1 *single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) InterfaceStubOnly(arg1 context.Context) ([]*single.Single, error) {
	fake.interfaceStubOnlyMutex.Lock()
	ret, specificReturn := fake.interfaceStubOnlyReturnsOnCall[len(fake.interfaceStubOnlyArgsForCall)]
	fake.interfaceStubOnlyArgsForCall = append(fake.interfaceStubOnlyArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("InterfaceStubOnly", []interface{}{arg1})
	fake.interfaceStubOnlyMutex.Unlock()
	if fake.InterfaceStubOnlyStub != nil {
		return fake.InterfaceStubOnlyStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.interfaceStubOnlyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSingleCollection) InterfaceStubOnlyCallCount() int {
	fake.interfaceStubOnlyMutex.RLock()
	defer fake.interfaceStubOnlyMutex.RUnlock()
	return len(fake.interfaceStubOnlyArgsForCall)
}

func (fake *FakeSingleCollection) InterfaceStubOnlyCalls(stub func(context.Context) ([]*single.Single, error)) {
	fake.interfaceStubOnlyMutex.Lock()
	defer fake.interfaceStubOnlyMutex.Unlock()
	fake.InterfaceStubOnlyStub = stub
}

func (fake *FakeSingleCollection) InterfaceStubOnlyArgsForCall(i int) context.Context {
	fake.interfaceStubOnlyMutex.RLock()
	defer fake.interfaceStubOnlyMutex.RUnlock()
	argsForCall := fake.interfaceStubOnlyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSingleCollection) InterfaceStubOnlyReturns(result1 []*single.Single, result2 error) {
	fake.interfaceStubOnlyMutex.Lock()
	defer fake.interfaceStubOnlyMutex.Unlock()
	fake.InterfaceStubOnlyStub = nil
	fake.interfaceStubOnlyReturns = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) InterfaceStubOnlyReturnsOnCall(i int, result1 []*single.Single, result2 error) {
	fake.interfaceStubOnlyMutex.Lock()
	defer fake.interfaceStubOnlyMutex.Unlock()
	fake.InterfaceStubOnlyStub = nil
	if fake.interfaceStubOnlyReturnsOnCall == nil {
		fake.interfaceStubOnlyReturnsOnCall = make(map[int]struct {
			result1 []*single.Single
			result2 error
		})
	}
	fake.interfaceStubOnlyReturnsOnCall[i] = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) MessageParam(arg1 context.Context, arg2 *single.Single_Message) ([]*single.Single, error) {
	fake.messageParamMutex.Lock()
	ret, specificReturn := fake.messageParamReturnsOnCall[len(fake.messageParamArgsForCall)]
	fake.messageParamArgsForCall = append(fake.messageParamArgsForCall, struct {
		arg1 context.Context
		arg2 *single.Single_Message
	}{arg1, arg2})
	fake.recordInvocation("MessageParam", []interface{}{arg1, arg2})
	fake.messageParamMutex.Unlock()
	if fake.MessageParamStub != nil {
		return fake.MessageParamStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.messageParamReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSingleCollection) MessageParamCallCount() int {
	fake.messageParamMutex.RLock()
	defer fake.messageParamMutex.RUnlock()
	return len(fake.messageParamArgsForCall)
}

func (fake *FakeSingleCollection) MessageParamCalls(stub func(context.Context, *single.Single_Message) ([]*single.Single, error)) {
	fake.messageParamMutex.Lock()
	defer fake.messageParamMutex.Unlock()
	fake.MessageParamStub = stub
}

func (fake *FakeSingleCollection) MessageParamArgsForCall(i int) (context.Context, *single.Single_Message) {
	fake.messageParamMutex.RLock()
	defer fake.messageParamMutex.RUnlock()
	argsForCall := fake.messageParamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSingleCollection) MessageParamReturns(result1 []*single.Single, result2 error) {
	fake.messageParamMutex.Lock()
	defer fake.messageParamMutex.Unlock()
	fake.MessageParamStub = nil
	fake.messageParamReturns = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) MessageParamReturnsOnCall(i int, result1 []*single.Single, result2 error) {
	fake.messageParamMutex.Lock()
	defer fake.messageParamMutex.Unlock()
	fake.MessageParamStub = nil
	if fake.messageParamReturnsOnCall == nil {
		fake.messageParamReturnsOnCall = make(map[int]struct {
			result1 []*single.Single
			result2 error
		})
	}
	fake.messageParamReturnsOnCall[i] = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) MultipleParam(arg1 context.Context, arg2 int32, arg3 int64, arg4 float32) ([]*single.Single, error) {
	fake.multipleParamMutex.Lock()
	ret, specificReturn := fake.multipleParamReturnsOnCall[len(fake.multipleParamArgsForCall)]
	fake.multipleParamArgsForCall = append(fake.multipleParamArgsForCall, struct {
		arg1 context.Context
		arg2 int32
		arg3 int64
		arg4 float32
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("MultipleParam", []interface{}{arg1, arg2, arg3, arg4})
	fake.multipleParamMutex.Unlock()
	if fake.MultipleParamStub != nil {
		return fake.MultipleParamStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.multipleParamReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSingleCollection) MultipleParamCallCount() int {
	fake.multipleParamMutex.RLock()
	defer fake.multipleParamMutex.RUnlock()
	return len(fake.multipleParamArgsForCall)
}

func (fake *FakeSingleCollection) MultipleParamCalls(stub func(context.Context, int32, int64, float32) ([]*single.Single, error)) {
	fake.multipleParamMutex.Lock()
	defer fake.multipleParamMutex.Unlock()
	fake.MultipleParamStub = stub
}

func (fake *FakeSingleCollection) MultipleParamArgsForCall(i int) (context.Context, int32, int64, float32) {
	fake.multipleParamMutex.RLock()
	defer fake.multipleParamMutex.RUnlock()
	argsForCall := fake.multipleParamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeSingleCollection) MultipleParamReturns(result1 []*single.Single, result2 error) {
	fake.multipleParamMutex.Lock()
	defer fake.multipleParamMutex.Unlock()
	fake.MultipleParamStub = nil
	fake.multipleParamReturns = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) MultipleParamReturnsOnCall(i int, result1 []*single.Single, result2 error) {
	fake.multipleParamMutex.Lock()
	defer fake.multipleParamMutex.Unlock()
	fake.MultipleParamStub = nil
	if fake.multipleParamReturnsOnCall == nil {
		fake.multipleParamReturnsOnCall = make(map[int]struct {
			result1 []*single.Single
			result2 error
		})
	}
	fake.multipleParamReturnsOnCall[i] = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) NameOf() string {
	fake.nameOfMutex.Lock()
	ret, specificReturn := fake.nameOfReturnsOnCall[len(fake.nameOfArgsForCall)]
	fake.nameOfArgsForCall = append(fake.nameOfArgsForCall, struct {
	}{})
	fake.recordInvocation("NameOf", []interface{}{})
	fake.nameOfMutex.Unlock()
	if fake.NameOfStub != nil {
		return fake.NameOfStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nameOfReturns
	return fakeReturns.result1
}

func (fake *FakeSingleCollection) NameOfCallCount() int {
	fake.nameOfMutex.RLock()
	defer fake.nameOfMutex.RUnlock()
	return len(fake.nameOfArgsForCall)
}

func (fake *FakeSingleCollection) NameOfCalls(stub func() string) {
	fake.nameOfMutex.Lock()
	defer fake.nameOfMutex.Unlock()
	fake.NameOfStub = stub
}

func (fake *FakeSingleCollection) NameOfReturns(result1 string) {
	fake.nameOfMutex.Lock()
	defer fake.nameOfMutex.Unlock()
	fake.NameOfStub = nil
	fake.nameOfReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeSingleCollection) NameOfReturnsOnCall(i int, result1 string) {
	fake.nameOfMutex.Lock()
	defer fake.nameOfMutex.Unlock()
	fake.NameOfStub = nil
	if fake.nameOfReturnsOnCall == nil {
		fake.nameOfReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameOfReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeSingleCollection) NonFieldOnly(arg1 context.Context, arg2 string) ([]*single.Single, error) {
	fake.nonFieldOnlyMutex.Lock()
	ret, specificReturn := fake.nonFieldOnlyReturnsOnCall[len(fake.nonFieldOnlyArgsForCall)]
	fake.nonFieldOnlyArgsForCall = append(fake.nonFieldOnlyArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("NonFieldOnly", []interface{}{arg1, arg2})
	fake.nonFieldOnlyMutex.Unlock()
	if fake.NonFieldOnlyStub != nil {
		return fake.NonFieldOnlyStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.nonFieldOnlyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSingleCollection) NonFieldOnlyCallCount() int {
	fake.nonFieldOnlyMutex.RLock()
	defer fake.nonFieldOnlyMutex.RUnlock()
	return len(fake.nonFieldOnlyArgsForCall)
}

func (fake *FakeSingleCollection) NonFieldOnlyCalls(stub func(context.Context, string) ([]*single.Single, error)) {
	fake.nonFieldOnlyMutex.Lock()
	defer fake.nonFieldOnlyMutex.Unlock()
	fake.NonFieldOnlyStub = stub
}

func (fake *FakeSingleCollection) NonFieldOnlyArgsForCall(i int) (context.Context, string) {
	fake.nonFieldOnlyMutex.RLock()
	defer fake.nonFieldOnlyMutex.RUnlock()
	argsForCall := fake.nonFieldOnlyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSingleCollection) NonFieldOnlyReturns(result1 []*single.Single, result2 error) {
	fake.nonFieldOnlyMutex.Lock()
	defer fake.nonFieldOnlyMutex.Unlock()
	fake.NonFieldOnlyStub = nil
	fake.nonFieldOnlyReturns = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) NonFieldOnlyReturnsOnCall(i int, result1 []*single.Single, result2 error) {
	fake.nonFieldOnlyMutex.Lock()
	defer fake.nonFieldOnlyMutex.Unlock()
	fake.NonFieldOnlyStub = nil
	if fake.nonFieldOnlyReturnsOnCall == nil {
		fake.nonFieldOnlyReturnsOnCall = make(map[int]struct {
			result1 []*single.Single
			result2 error
		})
	}
	fake.nonFieldOnlyReturnsOnCall[i] = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) OneParam(arg1 context.Context, arg2 int32) ([]*single.Single, error) {
	fake.oneParamMutex.Lock()
	ret, specificReturn := fake.oneParamReturnsOnCall[len(fake.oneParamArgsForCall)]
	fake.oneParamArgsForCall = append(fake.oneParamArgsForCall, struct {
		arg1 context.Context
		arg2 int32
	}{arg1, arg2})
	fake.recordInvocation("OneParam", []interface{}{arg1, arg2})
	fake.oneParamMutex.Unlock()
	if fake.OneParamStub != nil {
		return fake.OneParamStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.oneParamReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSingleCollection) OneParamCallCount() int {
	fake.oneParamMutex.RLock()
	defer fake.oneParamMutex.RUnlock()
	return len(fake.oneParamArgsForCall)
}

func (fake *FakeSingleCollection) OneParamCalls(stub func(context.Context, int32) ([]*single.Single, error)) {
	fake.oneParamMutex.Lock()
	defer fake.oneParamMutex.Unlock()
	fake.OneParamStub = stub
}

func (fake *FakeSingleCollection) OneParamArgsForCall(i int) (context.Context, int32) {
	fake.oneParamMutex.RLock()
	defer fake.oneParamMutex.RUnlock()
	argsForCall := fake.oneParamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSingleCollection) OneParamReturns(result1 []*single.Single, result2 error) {
	fake.oneParamMutex.Lock()
	defer fake.oneParamMutex.Unlock()
	fake.OneParamStub = nil
	fake.oneParamReturns = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) OneParamReturnsOnCall(i int, result1 []*single.Single, result2 error) {
	fake.oneParamMutex.Lock()
	defer fake.oneParamMutex.Unlock()
	fake.OneParamStub = nil
	if fake.oneParamReturnsOnCall == nil {
		fake.oneParamReturnsOnCall = make(map[int]struct {
			result1 []*single.Single
			result2 error
		})
	}
	fake.oneParamReturnsOnCall[i] = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) ProviderStubOnly(arg1 context.Context) ([]*single.Single, error) {
	fake.providerStubOnlyMutex.Lock()
	ret, specificReturn := fake.providerStubOnlyReturnsOnCall[len(fake.providerStubOnlyArgsForCall)]
	fake.providerStubOnlyArgsForCall = append(fake.providerStubOnlyArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("ProviderStubOnly", []interface{}{arg1})
	fake.providerStubOnlyMutex.Unlock()
	if fake.ProviderStubOnlyStub != nil {
		return fake.ProviderStubOnlyStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.providerStubOnlyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSingleCollection) ProviderStubOnlyCallCount() int {
	fake.providerStubOnlyMutex.RLock()
	defer fake.providerStubOnlyMutex.RUnlock()
	return len(fake.providerStubOnlyArgsForCall)
}

func (fake *FakeSingleCollection) ProviderStubOnlyCalls(stub func(context.Context) ([]*single.Single, error)) {
	fake.providerStubOnlyMutex.Lock()
	defer fake.providerStubOnlyMutex.Unlock()
	fake.ProviderStubOnlyStub = stub
}

func (fake *FakeSingleCollection) ProviderStubOnlyArgsForCall(i int) context.Context {
	fake.providerStubOnlyMutex.RLock()
	defer fake.providerStubOnlyMutex.RUnlock()
	argsForCall := fake.providerStubOnlyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSingleCollection) ProviderStubOnlyReturns(result1 []*single.Single, result2 error) {
	fake.providerStubOnlyMutex.Lock()
	defer fake.providerStubOnlyMutex.Unlock()
	fake.ProviderStubOnlyStub = nil
	fake.providerStubOnlyReturns = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) ProviderStubOnlyReturnsOnCall(i int, result1 []*single.Single, result2 error) {
	fake.providerStubOnlyMutex.Lock()
	defer fake.providerStubOnlyMutex.Unlock()
	fake.ProviderStubOnlyStub = nil
	if fake.providerStubOnlyReturnsOnCall == nil {
		fake.providerStubOnlyReturnsOnCall = make(map[int]struct {
			result1 []*single.Single
			result2 error
		})
	}
	fake.providerStubOnlyReturnsOnCall[i] = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) Shutdown(arg1 context.Context) error {
	fake.shutdownMutex.Lock()
	ret, specificReturn := fake.shutdownReturnsOnCall[len(fake.shutdownArgsForCall)]
	fake.shutdownArgsForCall = append(fake.shutdownArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Shutdown", []interface{}{arg1})
	fake.shutdownMutex.Unlock()
	if fake.ShutdownStub != nil {
		return fake.ShutdownStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.shutdownReturns
	return fakeReturns.result1
}

func (fake *FakeSingleCollection) ShutdownCallCount() int {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	return len(fake.shutdownArgsForCall)
}

func (fake *FakeSingleCollection) ShutdownCalls(stub func(context.Context) error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = stub
}

func (fake *FakeSingleCollection) ShutdownArgsForCall(i int) context.Context {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	argsForCall := fake.shutdownArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSingleCollection) ShutdownReturns(result1 error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	fake.shutdownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSingleCollection) ShutdownReturnsOnCall(i int, result1 error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	if fake.shutdownReturnsOnCall == nil {
		fake.shutdownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.shutdownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSingleCollection) String() string {
	fake.stringMutex.Lock()
	ret, specificReturn := fake.stringReturnsOnCall[len(fake.stringArgsForCall)]
	fake.stringArgsForCall = append(fake.stringArgsForCall, struct {
	}{})
	fake.recordInvocation("String", []interface{}{})
	fake.stringMutex.Unlock()
	if fake.StringStub != nil {
		return fake.StringStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.stringReturns
	return fakeReturns.result1
}

func (fake *FakeSingleCollection) StringCallCount() int {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	return len(fake.stringArgsForCall)
}

func (fake *FakeSingleCollection) StringCalls(stub func() string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = stub
}

func (fake *FakeSingleCollection) StringReturns(result1 string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	fake.stringReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeSingleCollection) StringReturnsOnCall(i int, result1 string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	if fake.stringReturnsOnCall == nil {
		fake.stringReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.stringReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeSingleCollection) Update(arg1 context.Context, arg2 *single.Single, arg3 *dal_single.SingleFieldValues) (*single.Single, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 *single.Single
		arg3 *dal_single.SingleFieldValues
	}{arg1, arg2, arg3})
	fake.recordInvocation("Update", []interface{}{arg1, arg2, arg3})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSingleCollection) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeSingleCollection) UpdateCalls(stub func(context.Context, *single.Single, *dal_single.SingleFieldValues) (*single.Single, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeSingleCollection) UpdateArgsForCall(i int) (context.Context, *single.Single, *dal_single.SingleFieldValues) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSingleCollection) UpdateReturns(result1 *single.Single, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) UpdateReturnsOnCall(i int, result1 *single.Single, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *single.Single
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) Upsert(arg1 context.Context, arg2 *single.Single) (*single.Single, error) {
	fake.upsertMutex.Lock()
	ret, specificReturn := fake.upsertReturnsOnCall[len(fake.upsertArgsForCall)]
	fake.upsertArgsForCall = append(fake.upsertArgsForCall, struct {
		arg1 context.Context
		arg2 *single.Single
	}{arg1, arg2})
	fake.recordInvocation("Upsert", []interface{}{arg1, arg2})
	fake.upsertMutex.Unlock()
	if fake.UpsertStub != nil {
		return fake.UpsertStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.upsertReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSingleCollection) UpsertCallCount() int {
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	return len(fake.upsertArgsForCall)
}

func (fake *FakeSingleCollection) UpsertCalls(stub func(context.Context, *single.Single) (*single.Single, error)) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = stub
}

func (fake *FakeSingleCollection) UpsertArgsForCall(i int) (context.Context, *single.Single) {
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	argsForCall := fake.upsertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSingleCollection) UpsertReturns(result1 *single.Single, result2 error) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = nil
	fake.upsertReturns = struct {
		result1 *single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) UpsertReturnsOnCall(i int, result1 *single.Single, result2 error) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = nil
	if fake.upsertReturnsOnCall == nil {
		fake.upsertReturnsOnCall = make(map[int]struct {
			result1 *single.Single
			result2 error
		})
	}
	fake.upsertReturnsOnCall[i] = struct {
		result1 *single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) WithComparator(arg1 context.Context, arg2 int32) ([]*single.Single, error) {
	fake.withComparatorMutex.Lock()
	ret, specificReturn := fake.withComparatorReturnsOnCall[len(fake.withComparatorArgsForCall)]
	fake.withComparatorArgsForCall = append(fake.withComparatorArgsForCall, struct {
		arg1 context.Context
		arg2 int32
	}{arg1, arg2})
	fake.recordInvocation("WithComparator", []interface{}{arg1, arg2})
	fake.withComparatorMutex.Unlock()
	if fake.WithComparatorStub != nil {
		return fake.WithComparatorStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.withComparatorReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSingleCollection) WithComparatorCallCount() int {
	fake.withComparatorMutex.RLock()
	defer fake.withComparatorMutex.RUnlock()
	return len(fake.withComparatorArgsForCall)
}

func (fake *FakeSingleCollection) WithComparatorCalls(stub func(context.Context, int32) ([]*single.Single, error)) {
	fake.withComparatorMutex.Lock()
	defer fake.withComparatorMutex.Unlock()
	fake.WithComparatorStub = stub
}

func (fake *FakeSingleCollection) WithComparatorArgsForCall(i int) (context.Context, int32) {
	fake.withComparatorMutex.RLock()
	defer fake.withComparatorMutex.RUnlock()
	argsForCall := fake.withComparatorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSingleCollection) WithComparatorReturns(result1 []*single.Single, result2 error) {
	fake.withComparatorMutex.Lock()
	defer fake.withComparatorMutex.Unlock()
	fake.WithComparatorStub = nil
	fake.withComparatorReturns = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) WithComparatorReturnsOnCall(i int, result1 []*single.Single, result2 error) {
	fake.withComparatorMutex.Lock()
	defer fake.withComparatorMutex.Unlock()
	fake.WithComparatorStub = nil
	if fake.withComparatorReturnsOnCall == nil {
		fake.withComparatorReturnsOnCall = make(map[int]struct {
			result1 []*single.Single
			result2 error
		})
	}
	fake.withComparatorReturnsOnCall[i] = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) WithDependencies(arg1 ...service.Service) {
	fake.withDependenciesMutex.Lock()
	fake.withDependenciesArgsForCall = append(fake.withDependenciesArgsForCall, struct {
		arg1 []service.Service
	}{arg1})
	fake.recordInvocation("WithDependencies", []interface{}{arg1})
	fake.withDependenciesMutex.Unlock()
	if fake.WithDependenciesStub != nil {
		fake.WithDependenciesStub(arg1...)
	}
}

func (fake *FakeSingleCollection) WithDependenciesCallCount() int {
	fake.withDependenciesMutex.RLock()
	defer fake.withDependenciesMutex.RUnlock()
	return len(fake.withDependenciesArgsForCall)
}

func (fake *FakeSingleCollection) WithDependenciesCalls(stub func(...service.Service)) {
	fake.withDependenciesMutex.Lock()
	defer fake.withDependenciesMutex.Unlock()
	fake.WithDependenciesStub = stub
}

func (fake *FakeSingleCollection) WithDependenciesArgsForCall(i int) []service.Service {
	fake.withDependenciesMutex.RLock()
	defer fake.withDependenciesMutex.RUnlock()
	argsForCall := fake.withDependenciesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSingleCollection) WithRest(arg1 context.Context, arg2 int32, arg3 int64, arg4 float32, arg5 float64) ([]*single.Single, error) {
	fake.withRestMutex.Lock()
	ret, specificReturn := fake.withRestReturnsOnCall[len(fake.withRestArgsForCall)]
	fake.withRestArgsForCall = append(fake.withRestArgsForCall, struct {
		arg1 context.Context
		arg2 int32
		arg3 int64
		arg4 float32
		arg5 float64
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("WithRest", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.withRestMutex.Unlock()
	if fake.WithRestStub != nil {
		return fake.WithRestStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.withRestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSingleCollection) WithRestCallCount() int {
	fake.withRestMutex.RLock()
	defer fake.withRestMutex.RUnlock()
	return len(fake.withRestArgsForCall)
}

func (fake *FakeSingleCollection) WithRestCalls(stub func(context.Context, int32, int64, float32, float64) ([]*single.Single, error)) {
	fake.withRestMutex.Lock()
	defer fake.withRestMutex.Unlock()
	fake.WithRestStub = stub
}

func (fake *FakeSingleCollection) WithRestArgsForCall(i int) (context.Context, int32, int64, float32, float64) {
	fake.withRestMutex.RLock()
	defer fake.withRestMutex.RUnlock()
	argsForCall := fake.withRestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeSingleCollection) WithRestReturns(result1 []*single.Single, result2 error) {
	fake.withRestMutex.Lock()
	defer fake.withRestMutex.Unlock()
	fake.WithRestStub = nil
	fake.withRestReturns = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) WithRestReturnsOnCall(i int, result1 []*single.Single, result2 error) {
	fake.withRestMutex.Lock()
	defer fake.withRestMutex.Unlock()
	fake.WithRestStub = nil
	if fake.withRestReturnsOnCall == nil {
		fake.withRestReturnsOnCall = make(map[int]struct {
			result1 []*single.Single
			result2 error
		})
	}
	fake.withRestReturnsOnCall[i] = struct {
		result1 []*single.Single
		result2 error
	}{result1, result2}
}

func (fake *FakeSingleCollection) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	fake.byIdMutex.RLock()
	defer fake.byIdMutex.RUnlock()
	fake.dependantsMutex.RLock()
	defer fake.dependantsMutex.RUnlock()
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	fake.interfaceStubOnlyMutex.RLock()
	defer fake.interfaceStubOnlyMutex.RUnlock()
	fake.messageParamMutex.RLock()
	defer fake.messageParamMutex.RUnlock()
	fake.multipleParamMutex.RLock()
	defer fake.multipleParamMutex.RUnlock()
	fake.nameOfMutex.RLock()
	defer fake.nameOfMutex.RUnlock()
	fake.nonFieldOnlyMutex.RLock()
	defer fake.nonFieldOnlyMutex.RUnlock()
	fake.oneParamMutex.RLock()
	defer fake.oneParamMutex.RUnlock()
	fake.providerStubOnlyMutex.RLock()
	defer fake.providerStubOnlyMutex.RUnlock()
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	fake.withComparatorMutex.RLock()
	defer fake.withComparatorMutex.RUnlock()
	fake.withDependenciesMutex.RLock()
	defer fake.withDependenciesMutex.RUnlock()
	fake.withRestMutex.RLock()
	defer fake.withRestMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSingleCollection) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dal_single.SingleCollection = new(FakeSingleCollection)
