// Package mongo_dal_single is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package mongo_dal_single

import (
	context "context"
	time "time"

	single "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/single"
	dal "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/single/dal"
	mongo "github.com/rleszilm/genms/mongo"
	bson "github.com/rleszilm/genms/mongo/bson"
	stats "go.opencensus.io/stats"
	tag "go.opencensus.io/tag"
)

// SingleConfig is a struct that can be used to configure a SingleCollection
type SingleConfig struct {
	Name       string        `envconfig:"name"`
	Database   string        `envconfig:"database"`
	Collection string        `envconfig:"collection"`
	Timeout    time.Duration `envconfig:"timeout" default:"5s"`
}

var (
	singleProjection = bson.M{
		"scalar_int32":     1,
		"scalar_int64":     1,
		"scalar_float32":   1,
		"scalar_float64":   1,
		"scalar_string":    1,
		"scalar_bytes":     1,
		"scalar_bool":      1,
		"many_scalar_bool": 1,
		"scalar_enum":      1,
		"obj_message":      1,
		"many_obj_message": 1,

		"aliased":          1,
		"ignored_postgres": 1,
		"renamed_postgres": 1,
		"ignored_rest":     1,
		"renamed_rest":     1,

		"aliased_mongo":      1,
		"_id":                1,
		"bson_bytes_oid":     1,
		"scalar_int32_opt":   1,
		"scalar_int64_opt":   1,
		"scalar_float32_opt": 1,
		"scalar_float64_opt": 1,
		"scalar_string_opt":  1,
		"scalar_bytes_opt":   1,
		"scalar_bool_opt":    1,
		"scalar_enum_opt":    1,
		"obj_message_opt":    1,

		"aliased_opt":          1,
		"ignored_postgres_opt": 1,
		"renamed_postgres_opt": 1,
		"ignored_rest_opt":     1,
		"renamed_rest_opt":     1,

		"aliased_mongo_opt":  1,
		"_id_opt":            1,
		"bson_bytes_oid_opt": 1,
	}
)

// SingleMongo is an autogenerated struct that
// is used to parse query results.
type SingleMongo struct {
	ScalarInt32    int32                    `bson:"scalar_int32,omitempty"`
	ScalarInt64    int64                    `bson:"scalar_int64,omitempty"`
	ScalarFloat32  float32                  `bson:"scalar_float32,omitempty"`
	ScalarFloat64  float64                  `bson:"scalar_float64,omitempty"`
	ScalarString   string                   `bson:"scalar_string,omitempty"`
	ScalarBytes    []byte                   `bson:"scalar_bytes,omitempty"`
	ScalarBool     bool                     `bson:"scalar_bool,omitempty"`
	ManyScalarBool []bool                   `bson:"many_scalar_bool,omitempty"`
	ScalarEnum     single.Single_Enum       `bson:"scalar_enum,omitempty"`
	ObjMessage     *single.Single_Message   `bson:"obj_message,omitempty"`
	ManyObjMessage []*single.Single_Message `bson:"many_obj_message,omitempty"`

	Renamed         string `bson:"aliased,omitempty"`
	IgnoredPostgres string `bson:"ignored_postgres,omitempty"`
	RenamedPostgres string `bson:"renamed_postgres,omitempty"`
	IgnoredRest     string `bson:"ignored_rest,omitempty"`
	RenamedRest     string `bson:"renamed_rest,omitempty"`

	RenamedMongo     string                 `bson:"aliased_mongo,omitempty"`
	BsonStringOid    bson.ObjectID          `bson:"_id,omitempty"`
	BsonBytesOid     bson.ObjectID          `bson:"bson_bytes_oid,omitempty"`
	ScalarInt32Opt   *int32                 `bson:"scalar_int32_opt,omitempty"`
	ScalarInt64Opt   *int64                 `bson:"scalar_int64_opt,omitempty"`
	ScalarFloat32Opt *float32               `bson:"scalar_float32_opt,omitempty"`
	ScalarFloat64Opt *float64               `bson:"scalar_float64_opt,omitempty"`
	ScalarStringOpt  *string                `bson:"scalar_string_opt,omitempty"`
	ScalarBytesOpt   []byte                 `bson:"scalar_bytes_opt,omitempty"`
	ScalarBoolOpt    *bool                  `bson:"scalar_bool_opt,omitempty"`
	ScalarEnumOpt    *single.Single_Enum    `bson:"scalar_enum_opt,omitempty"`
	ObjMessageOpt    *single.Single_Message `bson:"obj_message_opt,omitempty"`

	RenamedOpt         *string `bson:"aliased_opt,omitempty"`
	IgnoredPostgresOpt *string `bson:"ignored_postgres_opt,omitempty"`
	RenamedPostgresOpt *string `bson:"renamed_postgres_opt,omitempty"`
	IgnoredRestOpt     *string `bson:"ignored_rest_opt,omitempty"`
	RenamedRestOpt     *string `bson:"renamed_rest_opt,omitempty"`

	RenamedMongoOpt  *string        `bson:"aliased_mongo_opt,omitempty"`
	BsonStringOidOpt *bson.ObjectID `bson:"_id_opt,omitempty"`
	BsonBytesOidOpt  *bson.ObjectID `bson:"bson_bytes_oid_opt,omitempty"`
}

// Single returns a new single.Single populated with scanned values.
func (x *SingleMongo) Single() (*single.Single, error) {
	y := &single.Single{}

	y.ScalarInt32 = x.ScalarInt32
	y.ScalarInt64 = x.ScalarInt64
	y.ScalarFloat32 = x.ScalarFloat32
	y.ScalarFloat64 = x.ScalarFloat64
	y.ScalarString = x.ScalarString
	y.ScalarBytes = x.ScalarBytes
	y.ScalarBool = x.ScalarBool
	y.ManyScalarBool = x.ManyScalarBool
	y.ScalarEnum = x.ScalarEnum
	y.ObjMessage = x.ObjMessage
	y.ManyObjMessage = x.ManyObjMessage

	y.Renamed = x.Renamed
	y.IgnoredPostgres = x.IgnoredPostgres
	y.RenamedPostgres = x.RenamedPostgres
	y.IgnoredRest = x.IgnoredRest
	y.RenamedRest = x.RenamedRest

	y.RenamedMongo = x.RenamedMongo
	y.BsonStringOid = x.BsonStringOid.Hex()
	y.BsonBytesOid = (x.BsonBytesOid)[:]
	y.ScalarInt32Opt = x.ScalarInt32Opt
	y.ScalarInt64Opt = x.ScalarInt64Opt
	y.ScalarFloat32Opt = x.ScalarFloat32Opt
	y.ScalarFloat64Opt = x.ScalarFloat64Opt
	y.ScalarStringOpt = x.ScalarStringOpt
	y.ScalarBytesOpt = x.ScalarBytesOpt
	y.ScalarBoolOpt = x.ScalarBoolOpt
	y.ScalarEnumOpt = x.ScalarEnumOpt
	y.ObjMessageOpt = x.ObjMessageOpt

	y.RenamedOpt = x.RenamedOpt
	y.IgnoredPostgresOpt = x.IgnoredPostgresOpt
	y.RenamedPostgresOpt = x.RenamedPostgresOpt
	y.IgnoredRestOpt = x.IgnoredRestOpt
	y.RenamedRestOpt = x.RenamedRestOpt

	y.RenamedMongoOpt = x.RenamedMongoOpt

	y.BsonBytesOidOpt = (x.BsonBytesOidOpt)[:]
	return y, nil
}

// ToSingleMongo converts the given Single into the internal mongo equivalent.
func ToSingleMongo(obj *single.Single) (*SingleMongo, error) {
	mObj := &SingleMongo{}

	mObj.ScalarInt32 = obj.ScalarInt32
	mObj.ScalarInt64 = obj.ScalarInt64
	mObj.ScalarFloat32 = obj.ScalarFloat32
	mObj.ScalarFloat64 = obj.ScalarFloat64
	mObj.ScalarString = obj.ScalarString
	mObj.ScalarBytes = obj.ScalarBytes
	mObj.ScalarBool = obj.ScalarBool
	mObj.ManyScalarBool = obj.ManyScalarBool
	mObj.ScalarEnum = obj.ScalarEnum
	mObj.ObjMessage = obj.ObjMessage
	mObj.ManyObjMessage = obj.ManyObjMessage

	mObj.Renamed = obj.Renamed
	mObj.IgnoredPostgres = obj.IgnoredPostgres
	mObj.RenamedPostgres = obj.RenamedPostgres
	mObj.IgnoredRest = obj.IgnoredRest
	mObj.RenamedRest = obj.RenamedRest

	mObj.RenamedMongo = obj.RenamedMongo

	if obj.BsonStringOid != "" {
		convBsonStringOid, err := bson.ToObjectID(obj.BsonStringOid)
		if err != nil {
			return nil, err
		}
		mObj.BsonStringOid = convBsonStringOid
	}

	if len(obj.BsonBytesOid) != 0 {
		convBsonBytesOid, err := bson.ToObjectID(obj.BsonBytesOid)
		if err != nil {
			return nil, err
		}
		mObj.BsonBytesOid = convBsonBytesOid
	}

	mObj.ScalarInt32Opt = obj.ScalarInt32Opt
	mObj.ScalarInt64Opt = obj.ScalarInt64Opt
	mObj.ScalarFloat32Opt = obj.ScalarFloat32Opt
	mObj.ScalarFloat64Opt = obj.ScalarFloat64Opt
	mObj.ScalarStringOpt = obj.ScalarStringOpt
	mObj.ScalarBytesOpt = obj.ScalarBytesOpt
	mObj.ScalarBoolOpt = obj.ScalarBoolOpt
	mObj.ScalarEnumOpt = obj.ScalarEnumOpt
	mObj.ObjMessageOpt = obj.ObjMessageOpt

	mObj.RenamedOpt = obj.RenamedOpt
	mObj.IgnoredPostgresOpt = obj.IgnoredPostgresOpt
	mObj.RenamedPostgresOpt = obj.RenamedPostgresOpt
	mObj.IgnoredRestOpt = obj.IgnoredRestOpt
	mObj.RenamedRestOpt = obj.RenamedRestOpt

	mObj.RenamedMongoOpt = obj.RenamedMongoOpt

	if len(obj.BsonBytesOidOpt) != 0 {
		convBsonBytesOidOpt, err := bson.ToObjectID(obj.BsonBytesOidOpt)
		if err != nil {
			return nil, err
		}
		mObj.BsonBytesOidOpt = &convBsonBytesOidOpt
	}

	return mObj, nil
}

// SingleCollection is an autogenerated implementation of dal.SingleCollection.
type SingleCollection struct {
	dal.UnimplementedSingleCollection

	name          string
	dialer        mongo.Dialer
	config        *SingleConfig
	mutators      []dal.SingleMutator
	defaultFilter bson.M
}

// WithMutators adds dal.SingleMutators to the collection. These will be applied to all values after they are read from mongo.
func (x *SingleCollection) WithMutators(muts ...dal.SingleMutator) {
	x.mutators = append(x.mutators, muts...)
}

// WithDefaultFilter sets the default the default mongo filter to apply to all find queries. This is applied after any query args.
func (x *SingleCollection) WithDefaultFilter(f bson.M) {
	x.defaultFilter = f
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *SingleCollection) Initialize(_ context.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *SingleCollection) Shutdown(_ context.Context) error {
	return nil
}

// String returns a string identifier for the service.
func (x *SingleCollection) String() string {
	if x.name != "" {
		return "mongo-dal-single-single-" + x.name
	}
	return "mongo-dal-single-single"
}

// NameOf returns the name of a service. This must be unique if there are multiple instances of the same
// service.
func (x *SingleCollection) NameOf() string {
	return x.String()
}

// Find scans the collection for records matching the filter.
func (x *SingleCollection) Find(ctx context.Context, label string, filter bson.M, opts ...*mongo.FindOptions) ([]*single.Single, error) {
	ctx, cancel := context.WithTimeout(ctx, x.config.Timeout)
	defer cancel()

	client, err := x.dialer.Dial(ctx)
	if err != nil {
		logs.Error("could not dial:", err)
		stats.Record(ctx, mongo.MeasureError.M(1))
		return nil, err
	}
	defer client.Close(ctx)

	ctx, _ = tag.New(ctx,
		tag.Upsert(mongo.TagCollection, "single"),
		tag.Upsert(mongo.TagInstance, x.name),
		tag.Upsert(mongo.TagMethod, label),
	)
	stats.Record(ctx, mongo.MeasureInflight.M(1))
	start := time.Now()
	defer func(ctx context.Context) {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, mongo.MeasureLatency.M(dur), mongo.MeasureInflight.M(-1))
	}(ctx)

	for k, v := range x.defaultFilter {
		filter[k] = v
	}

	cur, err := client.
		Database(x.config.Database).
		Collection(x.config.Collection).
		Find(ctx, filter, singleProjection, opts...)
	if err != nil {
		logs.Error("could not execute rest request:", err)
		stats.Record(ctx, mongo.MeasureError.M(1))
		return nil, err
	}

	vals := []*single.Single{}
	for cur.Next(ctx) {
		obj := &SingleMongo{}
		if err = cur.Decode(obj); err != nil {
			logs.Errorf("could not parse %s - %v", label, err)
			stats.Record(ctx, mongo.MeasureError.M(1))
			return nil, err
		}

		val, err := obj.Single()
		if err != nil {
			logs.Error("could not convert from mongo to internal:", err)
			stats.Record(ctx, mongo.MeasureError.M(1))
			return nil, err
		}

		for _, m := range x.mutators {
			val, err = m(val)
			if err != nil {
				logs.Error("could not mutate value:", val, err)
				stats.Record(ctx, mongo.MeasureError.M(1))
				return nil, err
			}
		}

		vals = append(vals, val)
	}

	return vals, nil
}

// All implements dal.SingleCollection.All
func (x *SingleCollection) All(ctx context.Context) ([]*single.Single, error) {
	return x.Find(ctx, "all", bson.M{})
}

// Filter implements SingleCollectionReader
func (x *SingleCollection) Filter(ctx context.Context, fvs *dal.SingleFieldValues) ([]*single.Single, error) {
	filter := bson.M{}

	if fvs.ScalarInt32 != nil {
		filter["scalar_int32"] = *fvs.ScalarInt32
	}
	if fvs.ScalarInt64 != nil {
		filter["scalar_int64"] = *fvs.ScalarInt64
	}
	if fvs.ScalarFloat32 != nil {
		filter["scalar_float32"] = *fvs.ScalarFloat32
	}
	if fvs.ScalarFloat64 != nil {
		filter["scalar_float64"] = *fvs.ScalarFloat64
	}
	if fvs.ScalarString != nil {
		filter["scalar_string"] = *fvs.ScalarString
	}
	if fvs.ScalarBytes != nil {
		filter["scalar_bytes"] = *fvs.ScalarBytes
	}
	if fvs.ScalarBool != nil {
		filter["scalar_bool"] = *fvs.ScalarBool
	}
	if fvs.ManyScalarBool != nil {
		filter["many_scalar_bool"] = *fvs.ManyScalarBool
	}
	if fvs.ScalarEnum != nil {
		filter["scalar_enum"] = *fvs.ScalarEnum
	}
	if fvs.ObjMessage != nil {
		filter["obj_message"] = fvs.ObjMessage
	}
	if fvs.ManyObjMessage != nil {
		filter["many_obj_message"] = fvs.ManyObjMessage
	}

	if fvs.Renamed != nil {
		filter["aliased"] = *fvs.Renamed
	}
	if fvs.IgnoredPostgres != nil {
		filter["ignored_postgres"] = *fvs.IgnoredPostgres
	}
	if fvs.RenamedPostgres != nil {
		filter["renamed_postgres"] = *fvs.RenamedPostgres
	}
	if fvs.IgnoredRest != nil {
		filter["ignored_rest"] = *fvs.IgnoredRest
	}
	if fvs.RenamedRest != nil {
		filter["renamed_rest"] = *fvs.RenamedRest
	}

	if fvs.RenamedMongo != nil {
		filter["aliased_mongo"] = *fvs.RenamedMongo
	}
	if fvs.BsonStringOid != nil {
		convBsonStringOid, err := bson.ToObjectID(*fvs.BsonStringOid)
		if err != nil {
			logs.Error("could not convert value to ObjectID:", err)
			return nil, err
		}
		filter["_id"] = convBsonStringOid
	}
	if fvs.BsonBytesOid != nil {
		convBsonBytesOid, err := bson.ToObjectID(*fvs.BsonBytesOid)
		if err != nil {
			logs.Error("could not convert value to ObjectID:", err)
			return nil, err
		}
		filter["bson_bytes_oid"] = convBsonBytesOid
	}
	if fvs.ScalarInt32Opt != nil {
		filter["scalar_int32_opt"] = fvs.ScalarInt32Opt
	}
	if fvs.ScalarInt64Opt != nil {
		filter["scalar_int64_opt"] = fvs.ScalarInt64Opt
	}
	if fvs.ScalarFloat32Opt != nil {
		filter["scalar_float32_opt"] = fvs.ScalarFloat32Opt
	}
	if fvs.ScalarFloat64Opt != nil {
		filter["scalar_float64_opt"] = fvs.ScalarFloat64Opt
	}
	if fvs.ScalarStringOpt != nil {
		filter["scalar_string_opt"] = fvs.ScalarStringOpt
	}
	if fvs.ScalarBytesOpt != nil {
		filter["scalar_bytes_opt"] = fvs.ScalarBytesOpt
	}
	if fvs.ScalarBoolOpt != nil {
		filter["scalar_bool_opt"] = fvs.ScalarBoolOpt
	}
	if fvs.ScalarEnumOpt != nil {
		filter["scalar_enum_opt"] = fvs.ScalarEnumOpt
	}
	if fvs.ObjMessageOpt != nil {
		filter["obj_message_opt"] = fvs.ObjMessageOpt
	}

	if fvs.RenamedOpt != nil {
		filter["aliased_opt"] = fvs.RenamedOpt
	}
	if fvs.IgnoredPostgresOpt != nil {
		filter["ignored_postgres_opt"] = fvs.IgnoredPostgresOpt
	}
	if fvs.RenamedPostgresOpt != nil {
		filter["renamed_postgres_opt"] = fvs.RenamedPostgresOpt
	}
	if fvs.IgnoredRestOpt != nil {
		filter["ignored_rest_opt"] = fvs.IgnoredRestOpt
	}
	if fvs.RenamedRestOpt != nil {
		filter["renamed_rest_opt"] = fvs.RenamedRestOpt
	}

	if fvs.RenamedMongoOpt != nil {
		filter["aliased_mongo_opt"] = fvs.RenamedMongoOpt
	}
	if fvs.BsonStringOidOpt != nil {
		convBsonStringOidOpt, err := bson.ToObjectID(fvs.BsonStringOidOpt)
		if err != nil {
			logs.Error("could not convert value to ObjectID:", err)
			return nil, err
		}
		filter["_id_opt"] = convBsonStringOidOpt
	}
	if fvs.BsonBytesOidOpt != nil {
		convBsonBytesOidOpt, err := bson.ToObjectID(fvs.BsonBytesOidOpt)
		if err != nil {
			logs.Error("could not convert value to ObjectID:", err)
			return nil, err
		}
		filter["bson_bytes_oid_opt"] = convBsonBytesOidOpt
	}
	return x.Find(ctx, "filter", filter)
}

// Insert implements SingleCollectionWriter
func (x *SingleCollection) Insert(ctx context.Context, obj *single.Single) (*single.Single, error) {
	ctx, cancel := context.WithTimeout(ctx, x.config.Timeout)
	defer cancel()

	ctx, _ = tag.New(ctx,
		tag.Upsert(mongo.TagCollection, "single"),
		tag.Upsert(mongo.TagInstance, x.name),
		tag.Upsert(mongo.TagMethod, "insert"),
	)
	stats.Record(ctx, mongo.MeasureInflight.M(1))
	start := time.Now()
	defer func(ctx context.Context) {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, mongo.MeasureLatency.M(dur), mongo.MeasureInflight.M(-1))
	}(ctx)

	client, err := x.dialer.Dial(ctx)
	if err != nil {
		logs.Error("could not dial:", err)
		stats.Record(ctx, mongo.MeasureError.M(1))
		return nil, err
	}
	defer client.Close(ctx)

	mObj, err := ToSingleMongo(obj)
	if err != nil {
		logs.Error("could not convert internal to mongo:", obj, err)
		stats.Record(ctx, mongo.MeasureError.M(1))
		return nil, err
	}

	res, err := client.
		Database(x.config.Database).
		Collection(x.config.Collection).
		InsertOne(ctx, mObj)

	if err != nil {
		logs.Error("could not execute insert:", err)
		stats.Record(ctx, mongo.MeasureError.M(1))
		return nil, err
	}

	oid, ok := res.InsertedID.(bson.ObjectID)
	if !ok {
		logs.Error("could not convert returned upsert id:", oid, err)
		stats.Record(ctx, mongo.MeasureError.M(1))
		return nil, mongo.ErrBadObjID
	}

	obj.BsonStringOid = oid.Hex()

	return obj, nil
}

// Upsert implements SingleCollectionWriter
func (x *SingleCollection) Upsert(ctx context.Context, obj *single.Single) (*single.Single, error) {
	ctx, cancel := context.WithTimeout(ctx, x.config.Timeout)
	defer cancel()

	ctx, _ = tag.New(ctx,
		tag.Upsert(mongo.TagCollection, "single"),
		tag.Upsert(mongo.TagInstance, x.name),
		tag.Upsert(mongo.TagMethod, "upsert"),
	)
	stats.Record(ctx, mongo.MeasureInflight.M(1))
	start := time.Now()
	defer func(ctx context.Context) {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, mongo.MeasureLatency.M(dur), mongo.MeasureInflight.M(-1))
	}(ctx)

	client, err := x.dialer.Dial(ctx)
	if err != nil {
		logs.Error("could not dial:", err)
		stats.Record(ctx, mongo.MeasureError.M(1))
		return nil, err
	}
	defer client.Close(ctx)

	mObj, err := ToSingleMongo(obj)
	if err != nil {
		logs.Error("could not convert internal to mongo:", obj, err)
		stats.Record(ctx, mongo.MeasureError.M(1))
		return nil, err
	}

	opts := &mongo.UpdateOptions{}
	opts.SetUpsert(true)

	filter := bson.M{"_id": mObj.BsonStringOid}

	res, err := client.
		Database(x.config.Database).
		Collection(x.config.Collection).
		UpdateOne(ctx, filter, bson.M{"$set": mObj}, opts)

	if err != nil {
		logs.Error("could not execute upsert:", err)
		stats.Record(ctx, mongo.MeasureError.M(1))
		return nil, err
	}

	oid, ok := res.UpsertedID.(bson.ObjectID)
	if !ok {
		logs.Error("could not convert returned upsert id:", oid, err)
		stats.Record(ctx, mongo.MeasureError.M(1))
		return nil, mongo.ErrBadObjID
	}

	obj.BsonStringOid = oid.Hex()

	return obj, nil
}

// Update implements SingleCollectionWriter
func (x *SingleCollection) Update(ctx context.Context, obj *single.Single, fvs *dal.SingleFieldValues) (*single.Single, error) {
	ctx, cancel := context.WithTimeout(ctx, x.config.Timeout)
	defer cancel()

	ctx, _ = tag.New(ctx,
		tag.Upsert(mongo.TagCollection, "single"),
		tag.Upsert(mongo.TagInstance, x.name),
		tag.Upsert(mongo.TagMethod, "update"),
	)
	stats.Record(ctx, mongo.MeasureInflight.M(1))
	start := time.Now()
	defer func(ctx context.Context) {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, mongo.MeasureLatency.M(dur), mongo.MeasureInflight.M(-1))
	}(ctx)

	client, err := x.dialer.Dial(ctx)
	if err != nil {
		return nil, err
	}
	defer client.Close(ctx)

	objID, err := bson.ToObjectID(obj.BsonStringOid)
	if err != nil {
		logs.Error("could not convert to ObjectID:", obj.BsonStringOid, err)
		stats.Record(ctx, mongo.MeasureError.M(1))
		return nil, err
	}

	upd := bson.M{}
	if fvs.ScalarInt32 != nil {
		upd["scalar_int32"] = *fvs.ScalarInt32
	}
	if fvs.ScalarInt64 != nil {
		upd["scalar_int64"] = *fvs.ScalarInt64
	}
	if fvs.ScalarFloat32 != nil {
		upd["scalar_float32"] = *fvs.ScalarFloat32
	}
	if fvs.ScalarFloat64 != nil {
		upd["scalar_float64"] = *fvs.ScalarFloat64
	}
	if fvs.ScalarString != nil {
		upd["scalar_string"] = *fvs.ScalarString
	}
	if fvs.ScalarBytes != nil {
		upd["scalar_bytes"] = *fvs.ScalarBytes
	}
	if fvs.ScalarBool != nil {
		upd["scalar_bool"] = *fvs.ScalarBool
	}
	if fvs.ManyScalarBool != nil {
		upd["many_scalar_bool"] = *fvs.ManyScalarBool
	}
	if fvs.ScalarEnum != nil {
		upd["scalar_enum"] = *fvs.ScalarEnum
	}
	if fvs.ObjMessage != nil {
		upd["obj_message"] = fvs.ObjMessage
	}
	if fvs.ManyObjMessage != nil {
		upd["many_obj_message"] = fvs.ManyObjMessage
	}

	if fvs.Renamed != nil {
		upd["aliased"] = *fvs.Renamed
	}
	if fvs.IgnoredPostgres != nil {
		upd["ignored_postgres"] = *fvs.IgnoredPostgres
	}
	if fvs.RenamedPostgres != nil {
		upd["renamed_postgres"] = *fvs.RenamedPostgres
	}
	if fvs.IgnoredRest != nil {
		upd["ignored_rest"] = *fvs.IgnoredRest
	}
	if fvs.RenamedRest != nil {
		upd["renamed_rest"] = *fvs.RenamedRest
	}

	if fvs.RenamedMongo != nil {
		upd["aliased_mongo"] = *fvs.RenamedMongo
	}
	if fvs.BsonStringOid != nil {
		convBsonStringOid, err := bson.ToObjectID(*fvs.BsonStringOid)
		if err != nil {
			logs.Error("could not convert to ObjectID:", *fvs.BsonStringOid, err)
			stats.Record(ctx, mongo.MeasureError.M(1))
			return nil, err
		}
		upd["_id"] = convBsonStringOid
	}
	if fvs.BsonBytesOid != nil {
		convBsonBytesOid, err := bson.ToObjectID(*fvs.BsonBytesOid)
		if err != nil {
			logs.Error("could not convert to ObjectID:", *fvs.BsonBytesOid, err)
			stats.Record(ctx, mongo.MeasureError.M(1))
			return nil, err
		}
		upd["bson_bytes_oid"] = convBsonBytesOid
	}
	if fvs.ScalarInt32Opt != nil {
		upd["scalar_int32_opt"] = fvs.ScalarInt32Opt
	}
	if fvs.ScalarInt64Opt != nil {
		upd["scalar_int64_opt"] = fvs.ScalarInt64Opt
	}
	if fvs.ScalarFloat32Opt != nil {
		upd["scalar_float32_opt"] = fvs.ScalarFloat32Opt
	}
	if fvs.ScalarFloat64Opt != nil {
		upd["scalar_float64_opt"] = fvs.ScalarFloat64Opt
	}
	if fvs.ScalarStringOpt != nil {
		upd["scalar_string_opt"] = fvs.ScalarStringOpt
	}
	if fvs.ScalarBytesOpt != nil {
		upd["scalar_bytes_opt"] = fvs.ScalarBytesOpt
	}
	if fvs.ScalarBoolOpt != nil {
		upd["scalar_bool_opt"] = fvs.ScalarBoolOpt
	}
	if fvs.ScalarEnumOpt != nil {
		upd["scalar_enum_opt"] = fvs.ScalarEnumOpt
	}
	if fvs.ObjMessageOpt != nil {
		upd["obj_message_opt"] = fvs.ObjMessageOpt
	}

	if fvs.RenamedOpt != nil {
		upd["aliased_opt"] = fvs.RenamedOpt
	}
	if fvs.IgnoredPostgresOpt != nil {
		upd["ignored_postgres_opt"] = fvs.IgnoredPostgresOpt
	}
	if fvs.RenamedPostgresOpt != nil {
		upd["renamed_postgres_opt"] = fvs.RenamedPostgresOpt
	}
	if fvs.IgnoredRestOpt != nil {
		upd["ignored_rest_opt"] = fvs.IgnoredRestOpt
	}
	if fvs.RenamedRestOpt != nil {
		upd["renamed_rest_opt"] = fvs.RenamedRestOpt
	}

	if fvs.RenamedMongoOpt != nil {
		upd["aliased_mongo_opt"] = fvs.RenamedMongoOpt
	}
	if fvs.BsonStringOidOpt != nil {
		convBsonStringOidOpt, err := bson.ToObjectID(fvs.BsonStringOidOpt)
		if err != nil {
			logs.Error("could not convert to ObjectID:", fvs.BsonStringOidOpt, err)
			stats.Record(ctx, mongo.MeasureError.M(1))
			return nil, err
		}
		upd["_id_opt"] = convBsonStringOidOpt
	}
	if fvs.BsonBytesOidOpt != nil {
		convBsonBytesOidOpt, err := bson.ToObjectID(fvs.BsonBytesOidOpt)
		if err != nil {
			logs.Error("could not convert to ObjectID:", fvs.BsonBytesOidOpt, err)
			stats.Record(ctx, mongo.MeasureError.M(1))
			return nil, err
		}
		upd["bson_bytes_oid_opt"] = convBsonBytesOidOpt
	}
	filter := bson.M{"_id": objID}

	_, err = client.
		Database(x.config.Database).
		Collection(x.config.Collection).
		UpdateOne(ctx, filter, bson.M{"$set": upd})

	if err != nil {
		logs.Error("could not update:", err)
		stats.Record(ctx, mongo.MeasureError.M(1))
		return nil, err
	}

	if fvs.ScalarInt32 != nil {
		obj.ScalarInt32 = *fvs.ScalarInt32
	}
	if fvs.ScalarInt64 != nil {
		obj.ScalarInt64 = *fvs.ScalarInt64
	}
	if fvs.ScalarFloat32 != nil {
		obj.ScalarFloat32 = *fvs.ScalarFloat32
	}
	if fvs.ScalarFloat64 != nil {
		obj.ScalarFloat64 = *fvs.ScalarFloat64
	}
	if fvs.ScalarString != nil {
		obj.ScalarString = *fvs.ScalarString
	}
	if fvs.ScalarBytes != nil {
		obj.ScalarBytes = *fvs.ScalarBytes
	}
	if fvs.ScalarBool != nil {
		obj.ScalarBool = *fvs.ScalarBool
	}
	if fvs.ManyScalarBool != nil {
		obj.ManyScalarBool = *fvs.ManyScalarBool
	}
	if fvs.ScalarEnum != nil {
		obj.ScalarEnum = *fvs.ScalarEnum
	}
	if fvs.ObjMessage != nil {
		obj.ObjMessage = fvs.ObjMessage
	}
	if fvs.ManyObjMessage != nil {
		obj.ManyObjMessage = fvs.ManyObjMessage
	}

	if fvs.Renamed != nil {
		obj.Renamed = *fvs.Renamed
	}
	if fvs.IgnoredPostgres != nil {
		obj.IgnoredPostgres = *fvs.IgnoredPostgres
	}
	if fvs.RenamedPostgres != nil {
		obj.RenamedPostgres = *fvs.RenamedPostgres
	}
	if fvs.IgnoredRest != nil {
		obj.IgnoredRest = *fvs.IgnoredRest
	}
	if fvs.RenamedRest != nil {
		obj.RenamedRest = *fvs.RenamedRest
	}

	if fvs.RenamedMongo != nil {
		obj.RenamedMongo = *fvs.RenamedMongo
	}
	if fvs.BsonStringOid != nil {
		obj.BsonStringOid = *fvs.BsonStringOid
	}
	if fvs.BsonBytesOid != nil {
		obj.BsonBytesOid = *fvs.BsonBytesOid
	}
	if fvs.ScalarInt32Opt != nil {
		obj.ScalarInt32Opt = fvs.ScalarInt32Opt
	}
	if fvs.ScalarInt64Opt != nil {
		obj.ScalarInt64Opt = fvs.ScalarInt64Opt
	}
	if fvs.ScalarFloat32Opt != nil {
		obj.ScalarFloat32Opt = fvs.ScalarFloat32Opt
	}
	if fvs.ScalarFloat64Opt != nil {
		obj.ScalarFloat64Opt = fvs.ScalarFloat64Opt
	}
	if fvs.ScalarStringOpt != nil {
		obj.ScalarStringOpt = fvs.ScalarStringOpt
	}
	if fvs.ScalarBytesOpt != nil {
		obj.ScalarBytesOpt = fvs.ScalarBytesOpt
	}
	if fvs.ScalarBoolOpt != nil {
		obj.ScalarBoolOpt = fvs.ScalarBoolOpt
	}
	if fvs.ScalarEnumOpt != nil {
		obj.ScalarEnumOpt = fvs.ScalarEnumOpt
	}
	if fvs.ObjMessageOpt != nil {
		obj.ObjMessageOpt = fvs.ObjMessageOpt
	}

	if fvs.RenamedOpt != nil {
		obj.RenamedOpt = fvs.RenamedOpt
	}
	if fvs.IgnoredPostgresOpt != nil {
		obj.IgnoredPostgresOpt = fvs.IgnoredPostgresOpt
	}
	if fvs.RenamedPostgresOpt != nil {
		obj.RenamedPostgresOpt = fvs.RenamedPostgresOpt
	}
	if fvs.IgnoredRestOpt != nil {
		obj.IgnoredRestOpt = fvs.IgnoredRestOpt
	}
	if fvs.RenamedRestOpt != nil {
		obj.RenamedRestOpt = fvs.RenamedRestOpt
	}

	if fvs.RenamedMongoOpt != nil {
		obj.RenamedMongoOpt = fvs.RenamedMongoOpt
	}
	if fvs.BsonStringOidOpt != nil {
		obj.BsonStringOidOpt = fvs.BsonStringOidOpt
	}
	if fvs.BsonBytesOidOpt != nil {
		obj.BsonBytesOidOpt = fvs.BsonBytesOidOpt
	}
	return obj, nil
}

// ById implements dal.SingleCollection.ById
func (x *SingleCollection) ById(ctx context.Context, bson_string_oid string) ([]*single.Single, error) {
	ctx, _ = tag.New(ctx,
		tag.Upsert(mongo.TagCollection, "single"),
		tag.Upsert(mongo.TagInstance, x.name),
		tag.Upsert(mongo.TagMethod, "by_id"),
	)

	filter := bson.M{}

	convBsonStringOid, err := bson.ToObjectID(bson_string_oid)
	if err != nil {
		logs.Error("could not convert to ObjectID:", bson_string_oid, err)
		stats.Record(ctx, mongo.MeasureError.M(1))
		return nil, err
	}
	filter["_id"] = bson.M{"$eq": convBsonStringOid}

	return x.Find(ctx, "by_id", filter)
}

// OneParam implements dal.SingleCollection.OneParam
func (x *SingleCollection) OneParam(ctx context.Context, scalar_int32 int32) ([]*single.Single, error) {
	ctx, _ = tag.New(ctx,
		tag.Upsert(mongo.TagCollection, "single"),
		tag.Upsert(mongo.TagInstance, x.name),
		tag.Upsert(mongo.TagMethod, "one_param"),
	)

	filter := bson.M{}

	filter["scalar_int32"] = bson.M{"$eq": scalar_int32}

	return x.Find(ctx, "one_param", filter)
}

// MultipleParam implements dal.SingleCollection.MultipleParam
func (x *SingleCollection) MultipleParam(ctx context.Context, scalar_int32 int32, scalar_int64 int64, scalar_float32 float32) ([]*single.Single, error) {
	ctx, _ = tag.New(ctx,
		tag.Upsert(mongo.TagCollection, "single"),
		tag.Upsert(mongo.TagInstance, x.name),
		tag.Upsert(mongo.TagMethod, "multiple_param"),
	)

	filter := bson.M{}

	filter["scalar_int32"] = bson.M{"$eq": scalar_int32}

	filter["scalar_int64"] = bson.M{"$eq": scalar_int64}

	filter["scalar_float32"] = bson.M{"$eq": scalar_float32}

	return x.Find(ctx, "multiple_param", filter)
}

// MessageParam implements dal.SingleCollection.MessageParam
func (x *SingleCollection) MessageParam(ctx context.Context, obj_message *single.Single_Message) ([]*single.Single, error) {
	ctx, _ = tag.New(ctx,
		tag.Upsert(mongo.TagCollection, "single"),
		tag.Upsert(mongo.TagInstance, x.name),
		tag.Upsert(mongo.TagMethod, "message_param"),
	)

	filter := bson.M{}

	filter["obj_message"] = bson.M{"$eq": obj_message}

	return x.Find(ctx, "message_param", filter)
}

// WithComparator implements dal.SingleCollection.WithComparator
func (x *SingleCollection) WithComparator(ctx context.Context, scalar_int32 int32) ([]*single.Single, error) {
	ctx, _ = tag.New(ctx,
		tag.Upsert(mongo.TagCollection, "single"),
		tag.Upsert(mongo.TagInstance, x.name),
		tag.Upsert(mongo.TagMethod, "with_comparator"),
	)

	filter := bson.M{}

	filter["scalar_int32"] = bson.M{"$gt": scalar_int32}

	return x.Find(ctx, "with_comparator", filter)
}

// WithRest implements dal.SingleCollection.WithRest
func (x *SingleCollection) WithRest(ctx context.Context, scalar_int32 int32, scalar_int64 int64, scalar_float32 float32, scalar_float64 float64) ([]*single.Single, error) {
	ctx, _ = tag.New(ctx,
		tag.Upsert(mongo.TagCollection, "single"),
		tag.Upsert(mongo.TagInstance, x.name),
		tag.Upsert(mongo.TagMethod, "with_rest"),
	)

	filter := bson.M{}

	filter["scalar_int32"] = bson.M{"$eq": scalar_int32}

	filter["scalar_int64"] = bson.M{"$eq": scalar_int64}

	filter["scalar_float32"] = bson.M{"$eq": scalar_float32}

	filter["scalar_float64"] = bson.M{"$eq": scalar_float64}

	return x.Find(ctx, "with_rest", filter)
}

// ProviderStubOnly implements dal.SingleCollection.ProviderStubOnly
func (x *SingleCollection) ProviderStubOnly(ctx context.Context) ([]*single.Single, error) {
	ctx, _ = tag.New(ctx,
		tag.Upsert(mongo.TagCollection, "single"),
		tag.Upsert(mongo.TagInstance, x.name),
		tag.Upsert(mongo.TagMethod, "provider_stub_only"),
	)

	filter := bson.M{}

	return x.Find(ctx, "provider_stub_only", filter)
}

// NonFieldOnly implements dal.SingleCollection.NonFieldOnly
func (x *SingleCollection) NonFieldOnly(ctx context.Context, kind string) ([]*single.Single, error) {
	ctx, _ = tag.New(ctx,
		tag.Upsert(mongo.TagCollection, "single"),
		tag.Upsert(mongo.TagInstance, x.name),
		tag.Upsert(mongo.TagMethod, "non_field_only"),
	)

	filter := bson.M{}

	filter["kind"] = bson.M{"$eq": kind}

	return x.Find(ctx, "non_field_only", filter)
}

// NewSingleCollection returns a new SingleCollection.
func NewSingleCollection(instance string, dialer mongo.Dialer, config *SingleConfig) (*SingleCollection, error) {
	coll := &SingleCollection{
		name:   instance,
		dialer: dialer,
		config: config,
	}

	return coll, nil
}
