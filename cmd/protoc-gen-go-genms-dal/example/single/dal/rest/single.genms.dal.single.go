// Package rest_dal_single is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package rest_dal_single

import (
	bytes "bytes"
	context "context"
	json "encoding/json"
	fmt "fmt"
	ioutil "io/ioutil"
	http "net/http"
	url "net/url"
	strconv "strconv"
	template "text/template"
	time "time"

	copier "github.com/jinzhu/copier"
	single "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/single"
	dal "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/single/dal"
	rest "github.com/rleszilm/genms/rest"
	stats "go.opencensus.io/stats"
	tag "go.opencensus.io/tag"
)

// SingleCollection is an autogenerated implementation of dal.SingleCollection.
type SingleCollection struct {
	dal.UnimplementedSingleCollection

	name string

	client *http.Client
	config *SingleConfig

	url                     *url.URL
	urlAll                  string
	urlTmplById             *template.Template
	urlTmplOneParam         *template.Template
	urlTmplMultipleParam    *template.Template
	urlTmplMessageParam     *template.Template
	urlTmplWithComparator   *template.Template
	urlTmplWithRest         *template.Template
	urlTmplProviderStubOnly *template.Template

	urlTmplNonFieldOnly *template.Template
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *SingleCollection) Initialize(_ context.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *SingleCollection) Shutdown(_ context.Context) error {
	return nil
}

// String returns the name of the Collection.
func (x *SingleCollection) String() string {
	if x.name != "" {
		return "rest-dal-single-single-" + x.name
	}
	return "rest-dal-single-single"
}

// NameOf returns the name of the Collection.
func (x *SingleCollection) NameOf() string {
	return x.String()
}

// DoReq executes the given http request.
func (x *SingleCollection) DoReq(ctx context.Context, label string, req *http.Request) ([]*single.Single, error) {
	var err error
	var resp *http.Response

	start := time.Now()
	ctx, _ = tag.New(ctx,
		tag.Upsert(rest.TagCollection, "single"),
		tag.Upsert(rest.TagInstance, x.name),
		tag.Upsert(rest.TagMethod, label),
		tag.Upsert(rest.TagRestMethod, req.Method),
	)
	stats.Record(ctx, rest.MeasureInflight.M(1))
	defer func(ctx context.Context) {
		if resp != nil {
			ctx, _ = tag.New(ctx,
				tag.Upsert(rest.TagResponseCode, strconv.Itoa(resp.StatusCode)),
			)
		}

		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, rest.MeasureLatency.M(dur), rest.MeasureInflight.M(-1))
	}(ctx)

	ctx, cancel := context.WithTimeout(ctx, x.config.Timeout)
	defer cancel()

	resp, err = x.client.Do(req.WithContext(ctx))
	if err != nil {
		rest.Logs().Error("could not execute rest request:", err)
		stats.Record(ctx, rest.MeasureError.M(1))
		return nil, err
	}

	buff, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		rest.Logs().Error("could not read rest response:", err)
		stats.Record(ctx, rest.MeasureError.M(1))
		return nil, err
	}

	SingleScanners := []*SingleScanner{}
	if err := json.Unmarshal(buff, &SingleScanners); err != nil {
		rest.Logs().Error("could not unmarshal rest response:", err)
		stats.Record(ctx, rest.MeasureError.M(1))
		return nil, err
	}

	Singles := []*single.Single{}
	for _, c := range SingleScanners {
		Singles = append(Singles, c.Single())
	}
	return Singles, nil
}

// All implements dal.SingleCollection.All
func (x *SingleCollection) All(ctx context.Context) ([]*single.Single, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)
	u.Path = x.urlAll

	req := &http.Request{
		Method: "GET",
		Header: http.Header{},
		URL:    u,
	}

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	return x.DoReq(ctx, "all", req)
}

// ById implements dal.SingleCollection.ById
func (x *SingleCollection) ById(ctx context.Context, bson_string_oid string) ([]*single.Single, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)

	req := &http.Request{
		Method: "GET",
		Header: http.Header{},
		URL:    u,
	}

	queryValues := url.Values{}
	queryValues.Add("bson_string_oid", fmt.Sprintf("%v", bson_string_oid))

	req.URL.RawQuery = queryValues.Encode()

	pathValues := map[string]interface{}{}
	pathBuf := &bytes.Buffer{}
	if err := x.urlTmplById.Execute(pathBuf, pathValues); err != nil {
		return nil, err
	}
	req.URL.Path = pathBuf.String()

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	return x.DoReq(ctx, "by_id", req)
}

// OneParam implements dal.SingleCollection.OneParam
func (x *SingleCollection) OneParam(ctx context.Context, scalar_int32 int32) ([]*single.Single, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)

	req := &http.Request{
		Method: "GET",
		Header: http.Header{},
		URL:    u,
	}

	queryValues := url.Values{}
	queryValues.Add("scalar_int32", fmt.Sprintf("%v", scalar_int32))

	req.URL.RawQuery = queryValues.Encode()

	pathValues := map[string]interface{}{}
	pathBuf := &bytes.Buffer{}
	if err := x.urlTmplOneParam.Execute(pathBuf, pathValues); err != nil {
		return nil, err
	}
	req.URL.Path = pathBuf.String()

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	return x.DoReq(ctx, "one_param", req)
}

// MultipleParam implements dal.SingleCollection.MultipleParam
func (x *SingleCollection) MultipleParam(ctx context.Context, scalar_int32 int32, scalar_int64 int64, scalar_float32 float32) ([]*single.Single, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)

	req := &http.Request{
		Method: "GET",
		Header: http.Header{},
		URL:    u,
	}

	queryValues := url.Values{}
	queryValues.Add("scalar_int32", fmt.Sprintf("%v", scalar_int32))
	queryValues.Add("scalar_int64", fmt.Sprintf("%v", scalar_int64))
	queryValues.Add("scalar_float32", fmt.Sprintf("%v", scalar_float32))

	req.URL.RawQuery = queryValues.Encode()

	pathValues := map[string]interface{}{}
	pathBuf := &bytes.Buffer{}
	if err := x.urlTmplMultipleParam.Execute(pathBuf, pathValues); err != nil {
		return nil, err
	}
	req.URL.Path = pathBuf.String()

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	return x.DoReq(ctx, "multiple_param", req)
}

// MessageParam implements dal.SingleCollection.MessageParam
func (x *SingleCollection) MessageParam(ctx context.Context, obj_message *single.Single_Message) ([]*single.Single, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)

	req := &http.Request{
		Method: "GET",
		Header: http.Header{},
		URL:    u,
	}

	queryValues := url.Values{}
	queryValues.Add("obj_message", fmt.Sprintf("%v", obj_message))

	req.URL.RawQuery = queryValues.Encode()

	pathValues := map[string]interface{}{}
	pathBuf := &bytes.Buffer{}
	if err := x.urlTmplMessageParam.Execute(pathBuf, pathValues); err != nil {
		return nil, err
	}
	req.URL.Path = pathBuf.String()

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	return x.DoReq(ctx, "message_param", req)
}

// WithComparator implements dal.SingleCollection.WithComparator
func (x *SingleCollection) WithComparator(ctx context.Context, scalar_int32 int32) ([]*single.Single, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)

	req := &http.Request{
		Method: "GET",
		Header: http.Header{},
		URL:    u,
	}

	queryValues := url.Values{}
	queryValues.Add("scalar_int32", fmt.Sprintf("%v", scalar_int32))

	req.URL.RawQuery = queryValues.Encode()

	pathValues := map[string]interface{}{}
	pathBuf := &bytes.Buffer{}
	if err := x.urlTmplWithComparator.Execute(pathBuf, pathValues); err != nil {
		return nil, err
	}
	req.URL.Path = pathBuf.String()

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	return x.DoReq(ctx, "with_comparator", req)
}

// WithRest implements dal.SingleCollection.WithRest
func (x *SingleCollection) WithRest(ctx context.Context, scalar_int32 int32, scalar_int64 int64, scalar_float32 float32, scalar_float64 float64) ([]*single.Single, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)

	req := &http.Request{
		Method: "POST",
		Header: http.Header{},
		URL:    u,
	}

	queryValues := url.Values{}
	queryValues.Add("query_rest_scalar_int32", fmt.Sprintf("%v", scalar_int32))

	req.URL.RawQuery = queryValues.Encode()

	pathValues := map[string]interface{}{"scalar_int64": scalar_int64}
	pathBuf := &bytes.Buffer{}
	if err := x.urlTmplWithRest.Execute(pathBuf, pathValues); err != nil {
		return nil, err
	}
	req.URL.Path = pathBuf.String()

	bodyValues := map[string]interface{}{"scalar_float32": scalar_float32}
	bodyBytes, err := json.Marshal(bodyValues)
	if err != nil {
		return nil, err
	}
	bodyRC := ioutil.NopCloser(bytes.NewReader(bodyBytes))
	req.Body = bodyRC

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	req.Header.Add("scalar_float64", fmt.Sprintf("%v", scalar_float64))

	return x.DoReq(ctx, "with_rest", req)
}

// ProviderStubOnly implements dal.SingleCollection.ProviderStubOnly
func (x *SingleCollection) ProviderStubOnly(ctx context.Context) ([]*single.Single, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)

	req := &http.Request{
		Method: "GET",
		Header: http.Header{},
		URL:    u,
	}

	queryValues := url.Values{}

	req.URL.RawQuery = queryValues.Encode()

	pathValues := map[string]interface{}{}
	pathBuf := &bytes.Buffer{}
	if err := x.urlTmplProviderStubOnly.Execute(pathBuf, pathValues); err != nil {
		return nil, err
	}
	req.URL.Path = pathBuf.String()

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	return x.DoReq(ctx, "provider_stub_only", req)
}

// NonFieldOnly implements dal.SingleCollection.NonFieldOnly
func (x *SingleCollection) NonFieldOnly(ctx context.Context, kind string) ([]*single.Single, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)

	req := &http.Request{
		Method: "GET",
		Header: http.Header{},
		URL:    u,
	}

	queryValues := url.Values{}

	req.URL.RawQuery = queryValues.Encode()

	pathValues := map[string]interface{}{"kind": kind}
	pathBuf := &bytes.Buffer{}
	if err := x.urlTmplNonFieldOnly.Execute(pathBuf, pathValues); err != nil {
		return nil, err
	}
	req.URL.Path = pathBuf.String()

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	return x.DoReq(ctx, "non_field_only", req)
}

// NewSingleCollection returns a new SingleCollection.
func NewSingleCollection(instance string, client *http.Client, urls SingleUrlTemplateProvider, config *SingleConfig) (*SingleCollection, error) {
	coll := &SingleCollection{
		name:   instance,
		client: client,
		config: config,
	}

	u, err := url.Parse(config.URL)
	if err != nil {
		return nil, err
	}
	coll.url = u

	coll.urlAll = urls.All()
	if urls.ById() != "" {
		urlTmplById, err := template.New("urlTmplById").
			Funcs(template.FuncMap{}).
			Parse(urls.ById())
		if err != nil {
			return nil, err
		}
		coll.urlTmplById = urlTmplById
	}

	if urls.OneParam() != "" {
		urlTmplOneParam, err := template.New("urlTmplOneParam").
			Funcs(template.FuncMap{}).
			Parse(urls.OneParam())
		if err != nil {
			return nil, err
		}
		coll.urlTmplOneParam = urlTmplOneParam
	}

	if urls.MultipleParam() != "" {
		urlTmplMultipleParam, err := template.New("urlTmplMultipleParam").
			Funcs(template.FuncMap{}).
			Parse(urls.MultipleParam())
		if err != nil {
			return nil, err
		}
		coll.urlTmplMultipleParam = urlTmplMultipleParam
	}

	if urls.MessageParam() != "" {
		urlTmplMessageParam, err := template.New("urlTmplMessageParam").
			Funcs(template.FuncMap{}).
			Parse(urls.MessageParam())
		if err != nil {
			return nil, err
		}
		coll.urlTmplMessageParam = urlTmplMessageParam
	}

	if urls.WithComparator() != "" {
		urlTmplWithComparator, err := template.New("urlTmplWithComparator").
			Funcs(template.FuncMap{}).
			Parse(urls.WithComparator())
		if err != nil {
			return nil, err
		}
		coll.urlTmplWithComparator = urlTmplWithComparator
	}

	if urls.WithRest() != "" {
		urlTmplWithRest, err := template.New("urlTmplWithRest").
			Funcs(template.FuncMap{}).
			Parse(urls.WithRest())
		if err != nil {
			return nil, err
		}
		coll.urlTmplWithRest = urlTmplWithRest
	}

	if urls.ProviderStubOnly() != "" {
		urlTmplProviderStubOnly, err := template.New("urlTmplProviderStubOnly").
			Funcs(template.FuncMap{}).
			Parse(urls.ProviderStubOnly())
		if err != nil {
			return nil, err
		}
		coll.urlTmplProviderStubOnly = urlTmplProviderStubOnly
	}

	if urls.NonFieldOnly() != "" {
		urlTmplNonFieldOnly, err := template.New("urlTmplNonFieldOnly").
			Funcs(template.FuncMap{}).
			Parse(urls.NonFieldOnly())
		if err != nil {
			return nil, err
		}
		coll.urlTmplNonFieldOnly = urlTmplNonFieldOnly
	}

	return coll, nil
}

// SingleScanner is an autogenerated struct that
// is used to parse query results.
type SingleScanner struct {
	ScalarInt32    int32                    `json:"scalar_int32"`
	ScalarInt64    int64                    `json:"scalar_int64"`
	ScalarFloat32  float32                  `json:"scalar_float32"`
	ScalarFloat64  float64                  `json:"scalar_float64"`
	ScalarString   string                   `json:"scalar_string"`
	ScalarBytes    []byte                   `json:"scalar_bytes"`
	ScalarBool     bool                     `json:"scalar_bool"`
	ManyScalarBool []bool                   `json:"many_scalar_bool"`
	ScalarEnum     single.Single_Enum       `json:"scalar_enum"`
	ObjMessage     *single.Single_Message   `json:"obj_message"`
	ManyObjMessage []*single.Single_Message `json:"many_obj_message"`

	Renamed         string `json:"aliased"`
	IgnoredPostgres string `json:"ignored_postgres"`
	RenamedPostgres string `json:"renamed_postgres"`

	RenamedRest      string                 `json:"aliased_rest"`
	IgnoredMongo     string                 `json:"ignored_mongo"`
	RenamedMongo     string                 `json:"renamed_mongo"`
	BsonStringOid    string                 `json:"bson_string_oid"`
	BsonBytesOid     []byte                 `json:"bson_bytes_oid"`
	ScalarInt32Opt   *int32                 `json:"scalar_int32_opt"`
	ScalarInt64Opt   *int64                 `json:"scalar_int64_opt"`
	ScalarFloat32Opt *float32               `json:"scalar_float32_opt"`
	ScalarFloat64Opt *float64               `json:"scalar_float64_opt"`
	ScalarStringOpt  *string                `json:"scalar_string_opt"`
	ScalarBytesOpt   []byte                 `json:"scalar_bytes_opt"`
	ScalarBoolOpt    *bool                  `json:"scalar_bool_opt"`
	ScalarEnumOpt    *single.Single_Enum    `json:"scalar_enum_opt"`
	ObjMessageOpt    *single.Single_Message `json:"obj_message_opt"`

	RenamedOpt         *string `json:"aliased_opt"`
	IgnoredPostgresOpt *string `json:"ignored_postgres_opt"`
	RenamedPostgresOpt *string `json:"renamed_postgres_opt"`

	RenamedRestOpt   *string `json:"aliased_rest_opt"`
	IgnoredMongoOpt  *string `json:"ignored_mongo_opt"`
	RenamedMongoOpt  *string `json:"renamed_mongo_opt"`
	BsonStringOidOpt *string `json:"bson_string_oid_opt"`
	BsonBytesOidOpt  []byte  `json:"bson_bytes_oid_opt"`
}

// Single returns a new single.Single populated with scanned values.
func (x *SingleScanner) Single() *single.Single {
	y := &single.Single{}

	y.ScalarInt32 = x.ScalarInt32
	y.ScalarInt64 = x.ScalarInt64
	y.ScalarFloat32 = x.ScalarFloat32
	y.ScalarFloat64 = x.ScalarFloat64
	y.ScalarString = x.ScalarString
	y.ScalarBytes = x.ScalarBytes
	y.ScalarBool = x.ScalarBool
	y.ManyScalarBool = x.ManyScalarBool
	y.ScalarEnum = x.ScalarEnum
	y.ObjMessage = x.ObjMessage
	y.ManyObjMessage = x.ManyObjMessage

	y.Renamed = x.Renamed
	y.IgnoredPostgres = x.IgnoredPostgres
	y.RenamedPostgres = x.RenamedPostgres

	y.RenamedRest = x.RenamedRest
	y.IgnoredMongo = x.IgnoredMongo
	y.RenamedMongo = x.RenamedMongo
	y.BsonStringOid = x.BsonStringOid
	y.BsonBytesOid = x.BsonBytesOid
	y.ScalarInt32Opt = x.ScalarInt32Opt
	y.ScalarInt64Opt = x.ScalarInt64Opt
	y.ScalarFloat32Opt = x.ScalarFloat32Opt
	y.ScalarFloat64Opt = x.ScalarFloat64Opt
	y.ScalarStringOpt = x.ScalarStringOpt
	y.ScalarBytesOpt = x.ScalarBytesOpt
	y.ScalarBoolOpt = x.ScalarBoolOpt
	y.ScalarEnumOpt = x.ScalarEnumOpt
	y.ObjMessageOpt = x.ObjMessageOpt

	y.RenamedOpt = x.RenamedOpt
	y.IgnoredPostgresOpt = x.IgnoredPostgresOpt
	y.RenamedPostgresOpt = x.RenamedPostgresOpt

	y.RenamedRestOpt = x.RenamedRestOpt
	y.IgnoredMongoOpt = x.IgnoredMongoOpt
	y.RenamedMongoOpt = x.RenamedMongoOpt
	y.BsonStringOidOpt = x.BsonStringOidOpt
	y.BsonBytesOidOpt = x.BsonBytesOidOpt
	return y
}

// SingleConfig is a struct that can be used to configure a SingleCollection
type SingleConfig struct {
	URL     string            `envconfig:"url"`
	Name    string            `envconfig:"name"`
	Timeout time.Duration     `envconfig:"timeout" default:"5s"`
	Headers map[string]string `envconfig:"headers"`
}

// SingleUrlTemplateProvider is an interface that returns the query templated that should be executed
// to generate the queries that the collection will use.
//counterfeiter:generate .  SingleUrlTemplateProvider
type SingleUrlTemplateProvider interface {
	All() string
	ById() string
	OneParam() string
	MultipleParam() string
	MessageParam() string
	WithComparator() string
	WithRest() string
	ProviderStubOnly() string
	NonFieldOnly() string
}
