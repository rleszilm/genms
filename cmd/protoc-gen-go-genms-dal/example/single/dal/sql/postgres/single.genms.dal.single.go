// Package postgres_dal_single is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package postgres_dal_single

import (
	bytes "bytes"
	context "context"
	sql1 "database/sql"
	fmt "fmt"
	strings "strings"
	template "text/template"
	time "time"

	single "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/single"
	dal "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/single/dal"
	dal1 "github.com/rleszilm/genms/dal"
	sql "github.com/rleszilm/genms/sql"
	stats "go.opencensus.io/stats"
	tag "go.opencensus.io/tag"
)

// SingleCollection is an autogenerated implementation of dal.SingleCollection.
type SingleCollection struct {
	dal.UnimplementedSingleCollection

	name string

	db     sql.DB
	config *SingleConfig

	execInsert string
	execUpsert string
	queryAll   string

	execUpdateTmpl *template.Template

	queryById             string
	queryOneParam         string
	queryMultipleParam    string
	queryMessageParam     string
	queryWithComparator   string
	queryWithRest         string
	queryProviderStubOnly string

	queryNonFieldOnly string
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *SingleCollection) Initialize(_ context.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *SingleCollection) Shutdown(_ context.Context) error {
	return nil
}

// String returns the name of the Collection.
func (x *SingleCollection) String() string {
	if x.name != "" {
		return "postgres-dal-single-single-" + x.name
	}
	return "postgres-dal-single-single"
}

// NameOf returns the name of the Collection.
func (x *SingleCollection) NameOf() string {
	return x.String()
}

// DoInsert provides the base logic for dal.SingleCollection.Insert.
// The user should use this as a base for dal.SingleCollection.Insert, only having to add
// code that interprets the returned values.
func (x *SingleCollection) DoInsert(ctx context.Context, arg *single.Single) (sql1.Result, error) {
	start := time.Now()
	ctx, _ = tag.New(ctx,
		tag.Upsert(sql.TagCollection, "single"),
		tag.Upsert(sql.TagInstance, x.name),
		tag.Upsert(sql.TagQuery, "insert"),
		tag.Upsert(sql.TagDriver, "postgres"),
	)
	stats.Record(ctx, sql.MeasureInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, sql.MeasureLatency.M(dur), sql.MeasureInflight.M(-1))
	}()

	res, err := x.db.ExecWithReplacements(ctx, x.execInsert, singleWriterFromGeneric(arg))
	if err != nil {
		sql.Logs().Error("postgres: could not execute insert - ", err)
		stats.Record(ctx, sql.MeasureError.M(1))
		return nil, err
	}

	return res, err
}

// DoUpsert provides the base logic for dal.SingleCollection.Upsert.
// The user should use this as a base for dal.SingleCollection.Upsert, only having to add
// code that interprets the returned values.
func (x *SingleCollection) DoUpsert(ctx context.Context, arg *single.Single) (sql1.Result, error) {
	start := time.Now()
	ctx, _ = tag.New(ctx,
		tag.Upsert(sql.TagCollection, "single"),
		tag.Upsert(sql.TagInstance, x.name),
		tag.Upsert(sql.TagQuery, "upsert"),
		tag.Upsert(sql.TagDriver, "postgres"),
	)
	stats.Record(ctx, sql.MeasureInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, sql.MeasureLatency.M(dur), sql.MeasureInflight.M(-1))
	}()

	res, err := x.db.ExecWithReplacements(ctx, x.execUpsert, singleWriterFromGeneric(arg))
	if err != nil {
		sql.Logs().Error("postgres: could not execute upsert - ", err)
		stats.Record(ctx, sql.MeasureError.M(1))
		return nil, err
	}

	return res, err
}

// DoUpdate provides the base logic for dal.SingleCollection.Upsert.
// The user should use this as a base for dal.SingleCollection.Upsert, only having to add
// code that interprets the returned values.
func (x *SingleCollection) DoUpdate(ctx context.Context, fvs *dal.SingleFieldValues, clause string) (sql1.Result, error) {
	start := time.Now()
	ctx, _ = tag.New(ctx,
		tag.Upsert(sql.TagCollection, "single"),
		tag.Upsert(sql.TagInstance, x.name),
		tag.Upsert(sql.TagQuery, "update"),
		tag.Upsert(sql.TagDriver, "postgres"),
	)
	stats.Record(ctx, sql.MeasureInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, sql.MeasureLatency.M(dur), sql.MeasureInflight.M(-1))
	}()

	updates := []string{}

	if fvs.ScalarInt32 != nil {
		updates = append(updates, "scalar_int32 = :scalar_int32")
	}

	if fvs.ScalarInt64 != nil {
		updates = append(updates, "scalar_int64 = :scalar_int64")
	}

	if fvs.ScalarFloat32 != nil {
		updates = append(updates, "scalar_float32 = :scalar_float32")
	}

	if fvs.ScalarFloat64 != nil {
		updates = append(updates, "scalar_float64 = :scalar_float64")
	}

	if fvs.ScalarString != nil {
		updates = append(updates, "scalar_string = :scalar_string")
	}

	if fvs.ScalarBytes != nil {
		updates = append(updates, "scalar_bytes = :scalar_bytes")
	}

	if fvs.ScalarBool != nil {
		updates = append(updates, "scalar_bool = :scalar_bool")
	}

	if fvs.ManyScalarBool != nil {
		updates = append(updates, "many_scalar_bool = :many_scalar_bool")
	}

	if fvs.ScalarEnum != nil {
		updates = append(updates, "scalar_enum = :scalar_enum")
	}

	if fvs.ObjMessage != nil {
		updates = append(updates, "obj_message = :obj_message")
	}

	if fvs.ManyObjMessage != nil {
		updates = append(updates, "many_obj_message = :many_obj_message")
	}

	if fvs.Renamed != nil {
		updates = append(updates, "aliased = :aliased")
	}

	if fvs.RenamedPostgres != nil {
		updates = append(updates, "aliased_postgres = :aliased_postgres")
	}

	if fvs.IgnoredRest != nil {
		updates = append(updates, "ignored_rest = :ignored_rest")
	}

	if fvs.RenamedRest != nil {
		updates = append(updates, "renamed_rest = :renamed_rest")
	}

	if fvs.IgnoredMongo != nil {
		updates = append(updates, "ignored_mongo = :ignored_mongo")
	}

	if fvs.RenamedMongo != nil {
		updates = append(updates, "renamed_mongo = :renamed_mongo")
	}

	if fvs.BsonStringOid != nil {
		updates = append(updates, "bson_string_oid = :bson_string_oid")
	}

	if fvs.BsonBytesOid != nil {
		updates = append(updates, "bson_bytes_oid = :bson_bytes_oid")
	}

	if fvs.ScalarInt32Opt != nil {
		updates = append(updates, "scalar_int32_opt = :scalar_int32_opt")
	}

	if fvs.ScalarInt64Opt != nil {
		updates = append(updates, "scalar_int64_opt = :scalar_int64_opt")
	}

	if fvs.ScalarFloat32Opt != nil {
		updates = append(updates, "scalar_float32_opt = :scalar_float32_opt")
	}

	if fvs.ScalarFloat64Opt != nil {
		updates = append(updates, "scalar_float64_opt = :scalar_float64_opt")
	}

	if fvs.ScalarStringOpt != nil {
		updates = append(updates, "scalar_string_opt = :scalar_string_opt")
	}

	if fvs.ScalarBytesOpt != nil {
		updates = append(updates, "scalar_bytes_opt = :scalar_bytes_opt")
	}

	if fvs.ScalarBoolOpt != nil {
		updates = append(updates, "scalar_bool_opt = :scalar_bool_opt")
	}

	if fvs.ScalarEnumOpt != nil {
		updates = append(updates, "scalar_enum_opt = :scalar_enum_opt")
	}

	if fvs.ObjMessageOpt != nil {
		updates = append(updates, "obj_message_opt = :obj_message_opt")
	}

	if fvs.RenamedOpt != nil {
		updates = append(updates, "aliased_opt = :aliased_opt")
	}

	if fvs.RenamedPostgresOpt != nil {
		updates = append(updates, "aliased_postgres_opt = :aliased_postgres_opt")
	}

	if fvs.IgnoredRestOpt != nil {
		updates = append(updates, "ignored_rest_opt = :ignored_rest_opt")
	}

	if fvs.RenamedRestOpt != nil {
		updates = append(updates, "renamed_rest_opt = :renamed_rest_opt")
	}

	if fvs.IgnoredMongoOpt != nil {
		updates = append(updates, "ignored_mongo_opt = :ignored_mongo_opt")
	}

	if fvs.RenamedMongoOpt != nil {
		updates = append(updates, "renamed_mongo_opt = :renamed_mongo_opt")
	}

	if fvs.BsonStringOidOpt != nil {
		updates = append(updates, "bson_string_oid_opt = :bson_string_oid_opt")
	}

	if fvs.BsonBytesOidOpt != nil {
		updates = append(updates, "bson_bytes_oid_opt = :bson_bytes_oid_opt")
	}
	buf := &bytes.Buffer{}
	if err := x.execUpdateTmpl.Execute(buf, map[string]interface{}{
		"clause":  clause,
		"table":   x.config.TableName,
		"updates": strings.Join(updates, ", "),
	}); err != nil {
		sql.Logs().Error("postgres: could not format update - ", err)
		stats.Record(ctx, sql.MeasureError.M(1))
		return nil, err
	}

	res, err := x.db.ExecWithReplacements(ctx, string(buf.Bytes()), singleFieldValuesFromGeneric(fvs))
	if err != nil {
		sql.Logs().Error("could not execute update:", err)
		stats.Record(ctx, sql.MeasureError.M(1))
		return nil, err
	}

	return res, err
}

// All implements dal.SingleCollection.All
func (x *SingleCollection) All(ctx context.Context) ([]*single.Single, error) {
	return x.find(ctx, "all", x.queryAll, map[string]interface{}{})
}

// Filter implements dal.SingleCollection.Filter
func (x *SingleCollection) Filter(ctx context.Context, fvs *dal.SingleFieldValues) ([]*single.Single, error) {
	query := "SELECT scalar_int32, scalar_int64, scalar_float32, scalar_float64, scalar_string, scalar_bytes, scalar_bool, many_scalar_bool, scalar_enum, obj_message, many_obj_message, ignored, aliased, ignored_postgres, aliased_postgres, ignored_rest, renamed_rest, ignored_mongo, renamed_mongo, bson_string_oid, bson_bytes_oid, scalar_int32_opt, scalar_int64_opt, scalar_float32_opt, scalar_float64_opt, scalar_string_opt, scalar_bytes_opt, scalar_bool_opt, scalar_enum_opt, obj_message_opt, ignored_opt, aliased_opt, ignored_postgres_opt, aliased_postgres_opt, ignored_rest_opt, renamed_rest_opt, ignored_mongo_opt, renamed_mongo_opt, bson_string_oid_opt, bson_bytes_oid_opt FROM " + x.config.TableName

	fields := []string{}
	if fvs.ScalarInt32 != nil {
		fields = append(fields, "scalar_int32 = :scalar_int32")
	}
	if fvs.ScalarInt64 != nil {
		fields = append(fields, "scalar_int64 = :scalar_int64")
	}
	if fvs.ScalarFloat32 != nil {
		fields = append(fields, "scalar_float32 = :scalar_float32")
	}
	if fvs.ScalarFloat64 != nil {
		fields = append(fields, "scalar_float64 = :scalar_float64")
	}
	if fvs.ScalarString != nil {
		fields = append(fields, "scalar_string = :scalar_string")
	}
	if fvs.ScalarBytes != nil {
		fields = append(fields, "scalar_bytes = :scalar_bytes")
	}
	if fvs.ScalarBool != nil {
		fields = append(fields, "scalar_bool = :scalar_bool")
	}
	if fvs.ManyScalarBool != nil {
		fields = append(fields, "many_scalar_bool = :many_scalar_bool")
	}
	if fvs.ScalarEnum != nil {
		fields = append(fields, "scalar_enum = :scalar_enum")
	}
	if fvs.ObjMessage != nil {
		fields = append(fields, "obj_message = :obj_message")
	}
	if fvs.ManyObjMessage != nil {
		fields = append(fields, "many_obj_message = :many_obj_message")
	}

	if fvs.Renamed != nil {
		fields = append(fields, "aliased = :aliased")
	}

	if fvs.RenamedPostgres != nil {
		fields = append(fields, "aliased_postgres = :aliased_postgres")
	}
	if fvs.IgnoredRest != nil {
		fields = append(fields, "ignored_rest = :ignored_rest")
	}
	if fvs.RenamedRest != nil {
		fields = append(fields, "renamed_rest = :renamed_rest")
	}
	if fvs.IgnoredMongo != nil {
		fields = append(fields, "ignored_mongo = :ignored_mongo")
	}
	if fvs.RenamedMongo != nil {
		fields = append(fields, "renamed_mongo = :renamed_mongo")
	}
	if fvs.BsonStringOid != nil {
		fields = append(fields, "bson_string_oid = :bson_string_oid")
	}
	if fvs.BsonBytesOid != nil {
		fields = append(fields, "bson_bytes_oid = :bson_bytes_oid")
	}
	if fvs.ScalarInt32Opt != nil {
		fields = append(fields, "scalar_int32_opt = :scalar_int32_opt")
	}
	if fvs.ScalarInt64Opt != nil {
		fields = append(fields, "scalar_int64_opt = :scalar_int64_opt")
	}
	if fvs.ScalarFloat32Opt != nil {
		fields = append(fields, "scalar_float32_opt = :scalar_float32_opt")
	}
	if fvs.ScalarFloat64Opt != nil {
		fields = append(fields, "scalar_float64_opt = :scalar_float64_opt")
	}
	if fvs.ScalarStringOpt != nil {
		fields = append(fields, "scalar_string_opt = :scalar_string_opt")
	}
	if fvs.ScalarBytesOpt != nil {
		fields = append(fields, "scalar_bytes_opt = :scalar_bytes_opt")
	}
	if fvs.ScalarBoolOpt != nil {
		fields = append(fields, "scalar_bool_opt = :scalar_bool_opt")
	}
	if fvs.ScalarEnumOpt != nil {
		fields = append(fields, "scalar_enum_opt = :scalar_enum_opt")
	}
	if fvs.ObjMessageOpt != nil {
		fields = append(fields, "obj_message_opt = :obj_message_opt")
	}

	if fvs.RenamedOpt != nil {
		fields = append(fields, "aliased_opt = :aliased_opt")
	}

	if fvs.RenamedPostgresOpt != nil {
		fields = append(fields, "aliased_postgres_opt = :aliased_postgres_opt")
	}
	if fvs.IgnoredRestOpt != nil {
		fields = append(fields, "ignored_rest_opt = :ignored_rest_opt")
	}
	if fvs.RenamedRestOpt != nil {
		fields = append(fields, "renamed_rest_opt = :renamed_rest_opt")
	}
	if fvs.IgnoredMongoOpt != nil {
		fields = append(fields, "ignored_mongo_opt = :ignored_mongo_opt")
	}
	if fvs.RenamedMongoOpt != nil {
		fields = append(fields, "renamed_mongo_opt = :renamed_mongo_opt")
	}
	if fvs.BsonStringOidOpt != nil {
		fields = append(fields, "bson_string_oid_opt = :bson_string_oid_opt")
	}
	if fvs.BsonBytesOidOpt != nil {
		fields = append(fields, "bson_bytes_oid_opt = :bson_bytes_oid_opt")
	}
	if len(fields) > 0 {
		query = fmt.Sprintf("%s WHERE %s", query, strings.Join(fields, " AND "))
	}

	return x.find(ctx, "filter", query, singleFieldValuesFromGeneric(fvs))
}

func (x *SingleCollection) find(ctx context.Context, label string, query string, fvs interface{}) ([]*single.Single, error) {
	start := time.Now()
	ctx, _ = tag.New(ctx,
		tag.Upsert(sql.TagCollection, "single"),
		tag.Upsert(sql.TagInstance, x.name),
		tag.Upsert(sql.TagQuery, label),
		tag.Upsert(sql.TagDriver, "postgres"),
	)
	stats.Record(ctx, sql.MeasureInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, sql.MeasureLatency.M(dur), sql.MeasureInflight.M(-1))
	}()

	rows, err := x.db.QueryWithReplacements(ctx, query, fvs)
	if err != nil {
		sql.Logs().Errorf("could not execute %s - %v", label, err)
		stats.Record(ctx, sql.MeasureError.M(1))
		return nil, err
	}
	defer rows.Close()

	Singles := []*single.Single{}
	for rows.Next() {
		obj := &SingleScanner{}
		if err = rows.StructScan(obj); err != nil {
			sql.Logs().Errorf("could not parse %s - %v", label, err)
			stats.Record(ctx, sql.MeasureError.M(1))
			return nil, err
		}
		Singles = append(Singles, obj.Single())
	}
	return Singles, nil
}

// ById implements dal.SingleCollection.ById
func (x *SingleCollection) ById(ctx context.Context, bson_string_oid string) ([]*single.Single, error) {
	fvs := map[string]interface{}{"bson_string_oid": bson_string_oid}
	return x.find(ctx, "by_id", x.queryById, fvs)
}

// OneParam implements dal.SingleCollection.OneParam
func (x *SingleCollection) OneParam(ctx context.Context, scalar_int32 int32) ([]*single.Single, error) {
	fvs := map[string]interface{}{"scalar_int32": scalar_int32}
	return x.find(ctx, "one_param", x.queryOneParam, fvs)
}

// MultipleParam implements dal.SingleCollection.MultipleParam
func (x *SingleCollection) MultipleParam(ctx context.Context, scalar_int32 int32, scalar_int64 int64, scalar_float32 float32) ([]*single.Single, error) {
	fvs := map[string]interface{}{"scalar_int32": scalar_int32, "scalar_int64": scalar_int64, "scalar_float32": scalar_float32}
	return x.find(ctx, "multiple_param", x.queryMultipleParam, fvs)
}

// MessageParam implements dal.SingleCollection.MessageParam
func (x *SingleCollection) MessageParam(ctx context.Context, obj_message *single.Single_Message) ([]*single.Single, error) {
	fvs := map[string]interface{}{"obj_message": &obj_message}
	return x.find(ctx, "message_param", x.queryMessageParam, fvs)
}

// WithComparator implements dal.SingleCollection.WithComparator
func (x *SingleCollection) WithComparator(ctx context.Context, scalar_int32 int32) ([]*single.Single, error) {
	fvs := map[string]interface{}{"scalar_int32": scalar_int32}
	return x.find(ctx, "with_comparator", x.queryWithComparator, fvs)
}

// WithRest implements dal.SingleCollection.WithRest
func (x *SingleCollection) WithRest(ctx context.Context, scalar_int32 int32, scalar_int64 int64, scalar_float32 float32, scalar_float64 float64) ([]*single.Single, error) {
	fvs := map[string]interface{}{"scalar_int32": scalar_int32, "scalar_int64": scalar_int64, "scalar_float32": scalar_float32, "scalar_float64": scalar_float64}
	return x.find(ctx, "with_rest", x.queryWithRest, fvs)
}

// ProviderStubOnly implements dal.SingleCollection.ProviderStubOnly
func (x *SingleCollection) ProviderStubOnly(ctx context.Context) ([]*single.Single, error) {
	fvs := map[string]interface{}{}
	return x.find(ctx, "provider_stub_only", x.queryProviderStubOnly, fvs)
}

// NonFieldOnly implements dal.SingleCollection.NonFieldOnly
func (x *SingleCollection) NonFieldOnly(ctx context.Context, kind string) ([]*single.Single, error) {
	fvs := map[string]interface{}{"kind": kind}
	return x.find(ctx, "non_field_only", x.queryNonFieldOnly, fvs)
}

// NewSingleCollection returns a new SingleCollection.
func NewSingleCollection(instance string, db sql.DB, queries SingleQueryTemplateProvider, config *SingleConfig) (*SingleCollection, error) {
	coll := &SingleCollection{
		name:   instance,
		db:     db,
		config: config,
	}

	queryReplacements := map[string]string{
		"table":       config.TableName,
		"fields":      "scalar_int32, scalar_int64, scalar_float32, scalar_float64, scalar_string, scalar_bytes, scalar_bool, many_scalar_bool, scalar_enum, obj_message, many_obj_message, ignored, aliased, ignored_postgres, aliased_postgres, ignored_rest, renamed_rest, ignored_mongo, renamed_mongo, bson_string_oid, bson_bytes_oid, scalar_int32_opt, scalar_int64_opt, scalar_float32_opt, scalar_float64_opt, scalar_string_opt, scalar_bytes_opt, scalar_bool_opt, scalar_enum_opt, obj_message_opt, ignored_opt, aliased_opt, ignored_postgres_opt, aliased_postgres_opt, ignored_rest_opt, renamed_rest_opt, ignored_mongo_opt, renamed_mongo_opt, bson_string_oid_opt, bson_bytes_oid_opt",
		"writeFields": ":scalar_int32, :scalar_int64, :scalar_float32, :scalar_float64, :scalar_string, :scalar_bytes, :scalar_bool, :many_scalar_bool, :scalar_enum, :obj_message, :many_obj_message, :ignored, :aliased, :ignored_postgres, :aliased_postgres, :ignored_rest, :renamed_rest, :ignored_mongo, :renamed_mongo, :bson_string_oid, :bson_bytes_oid, :scalar_int32_opt, :scalar_int64_opt, :scalar_float32_opt, :scalar_float64_opt, :scalar_string_opt, :scalar_bytes_opt, :scalar_bool_opt, :scalar_enum_opt, :obj_message_opt, :ignored_opt, :aliased_opt, :ignored_postgres_opt, :aliased_postgres_opt, :ignored_rest_opt, :renamed_rest_opt, :ignored_mongo_opt, :renamed_mongo_opt, :bson_string_oid_opt, :bson_bytes_oid_opt",
	}

	// generate Insert exec
	execInsert, err := dal1.RenderQuery("dal.Single-exec-insert", queries.Insert(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.execInsert = execInsert

	// generate Upsert exec
	execUpsert, err := dal1.RenderQuery("dal.Single-exec-upsert", queries.Upsert(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.execUpsert = execUpsert

	execUpdateTmpl, err := template.New("dal.Single-exec-update").
		Funcs(template.FuncMap{}).
		Parse(queries.Update())

	if err != nil {
		return nil, err
	}
	coll.execUpdateTmpl = execUpdateTmpl

	// generate All query
	queryAll, err := dal1.RenderQuery("dal.Single-query-all", queries.All(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryAll = queryAll

	// generate ById query
	queryById, err := dal1.RenderQuery("dal.Single-query-by_id", queries.ById(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryById = queryById

	// generate OneParam query
	queryOneParam, err := dal1.RenderQuery("dal.Single-query-one_param", queries.OneParam(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryOneParam = queryOneParam

	// generate MultipleParam query
	queryMultipleParam, err := dal1.RenderQuery("dal.Single-query-multiple_param", queries.MultipleParam(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryMultipleParam = queryMultipleParam

	// generate MessageParam query
	queryMessageParam, err := dal1.RenderQuery("dal.Single-query-message_param", queries.MessageParam(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryMessageParam = queryMessageParam

	// generate WithComparator query
	queryWithComparator, err := dal1.RenderQuery("dal.Single-query-with_comparator", queries.WithComparator(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryWithComparator = queryWithComparator

	// generate WithRest query
	queryWithRest, err := dal1.RenderQuery("dal.Single-query-with_rest", queries.WithRest(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryWithRest = queryWithRest

	// generate ProviderStubOnly query
	queryProviderStubOnly, err := dal1.RenderQuery("dal.Single-query-provider_stub_only", queries.ProviderStubOnly(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryProviderStubOnly = queryProviderStubOnly

	// generate NonFieldOnly query
	queryNonFieldOnly, err := dal1.RenderQuery("dal.Single-query-non_field_only", queries.NonFieldOnly(), queryReplacements)
	if err != nil {
		return nil, err
	}
	coll.queryNonFieldOnly = queryNonFieldOnly

	return coll, nil
}

// SingleFieldValues is an autogenerated struct that is used in generic Single queries.
type SingleFieldValues struct {
	ScalarInt32    *int32                   `db:"scalar_int32"`
	ScalarInt64    *int64                   `db:"scalar_int64"`
	ScalarFloat32  *float32                 `db:"scalar_float32"`
	ScalarFloat64  *float64                 `db:"scalar_float64"`
	ScalarString   *string                  `db:"scalar_string"`
	ScalarBytes    *[]byte                  `db:"scalar_bytes"`
	ScalarBool     *bool                    `db:"scalar_bool"`
	ManyScalarBool *[]bool                  `db:"many_scalar_bool"`
	ScalarEnum     *single.Single_Enum      `db:"scalar_enum"`
	ObjMessage     *single.Single_Message   `db:"obj_message"`
	ManyObjMessage []*single.Single_Message `db:"many_obj_message"`

	Renamed *string `db:"aliased"`

	RenamedPostgres  *string                `db:"aliased_postgres"`
	IgnoredRest      *string                `db:"ignored_rest"`
	RenamedRest      *string                `db:"renamed_rest"`
	IgnoredMongo     *string                `db:"ignored_mongo"`
	RenamedMongo     *string                `db:"renamed_mongo"`
	BsonStringOid    *string                `db:"bson_string_oid"`
	BsonBytesOid     *[]byte                `db:"bson_bytes_oid"`
	ScalarInt32Opt   *int32                 `db:"scalar_int32_opt"`
	ScalarInt64Opt   *int64                 `db:"scalar_int64_opt"`
	ScalarFloat32Opt *float32               `db:"scalar_float32_opt"`
	ScalarFloat64Opt *float64               `db:"scalar_float64_opt"`
	ScalarStringOpt  *string                `db:"scalar_string_opt"`
	ScalarBytesOpt   []byte                 `db:"scalar_bytes_opt"`
	ScalarBoolOpt    *bool                  `db:"scalar_bool_opt"`
	ScalarEnumOpt    *single.Single_Enum    `db:"scalar_enum_opt"`
	ObjMessageOpt    *single.Single_Message `db:"obj_message_opt"`

	RenamedOpt *string `db:"aliased_opt"`

	RenamedPostgresOpt *string `db:"aliased_postgres_opt"`
	IgnoredRestOpt     *string `db:"ignored_rest_opt"`
	RenamedRestOpt     *string `db:"renamed_rest_opt"`
	IgnoredMongoOpt    *string `db:"ignored_mongo_opt"`
	RenamedMongoOpt    *string `db:"renamed_mongo_opt"`
	BsonStringOidOpt   *string `db:"bson_string_oid_opt"`
	BsonBytesOidOpt    []byte  `db:"bson_bytes_oid_opt"`
}

func singleFieldValuesFromGeneric(y *dal.SingleFieldValues) *SingleFieldValues {
	f := &SingleFieldValues{}
	if y.ScalarInt32 != nil {
		f.ScalarInt32 = y.ScalarInt32
	}
	if y.ScalarInt64 != nil {
		f.ScalarInt64 = y.ScalarInt64
	}
	if y.ScalarFloat32 != nil {
		f.ScalarFloat32 = y.ScalarFloat32
	}
	if y.ScalarFloat64 != nil {
		f.ScalarFloat64 = y.ScalarFloat64
	}
	if y.ScalarString != nil {
		f.ScalarString = y.ScalarString
	}
	if y.ScalarBytes != nil {
		f.ScalarBytes = y.ScalarBytes
	}
	if y.ScalarBool != nil {
		f.ScalarBool = y.ScalarBool
	}
	if y.ManyScalarBool != nil {
		f.ManyScalarBool = y.ManyScalarBool
	}
	if y.ScalarEnum != nil {
		f.ScalarEnum = y.ScalarEnum
	}
	if y.ObjMessage != nil {
		f.ObjMessage = y.ObjMessage
	}
	if y.ManyObjMessage != nil {
		f.ManyObjMessage = y.ManyObjMessage
	}

	if y.Renamed != nil {
		f.Renamed = y.Renamed
	}

	if y.RenamedPostgres != nil {
		f.RenamedPostgres = y.RenamedPostgres
	}
	if y.IgnoredRest != nil {
		f.IgnoredRest = y.IgnoredRest
	}
	if y.RenamedRest != nil {
		f.RenamedRest = y.RenamedRest
	}
	if y.IgnoredMongo != nil {
		f.IgnoredMongo = y.IgnoredMongo
	}
	if y.RenamedMongo != nil {
		f.RenamedMongo = y.RenamedMongo
	}
	if y.BsonStringOid != nil {
		f.BsonStringOid = y.BsonStringOid
	}
	if y.BsonBytesOid != nil {
		f.BsonBytesOid = y.BsonBytesOid
	}
	if y.ScalarInt32Opt != nil {
		f.ScalarInt32Opt = y.ScalarInt32Opt
	}
	if y.ScalarInt64Opt != nil {
		f.ScalarInt64Opt = y.ScalarInt64Opt
	}
	if y.ScalarFloat32Opt != nil {
		f.ScalarFloat32Opt = y.ScalarFloat32Opt
	}
	if y.ScalarFloat64Opt != nil {
		f.ScalarFloat64Opt = y.ScalarFloat64Opt
	}
	if y.ScalarStringOpt != nil {
		f.ScalarStringOpt = y.ScalarStringOpt
	}
	if y.ScalarBytesOpt != nil {
		f.ScalarBytesOpt = y.ScalarBytesOpt
	}
	if y.ScalarBoolOpt != nil {
		f.ScalarBoolOpt = y.ScalarBoolOpt
	}
	if y.ScalarEnumOpt != nil {
		f.ScalarEnumOpt = y.ScalarEnumOpt
	}
	if y.ObjMessageOpt != nil {
		f.ObjMessageOpt = y.ObjMessageOpt
	}

	if y.RenamedOpt != nil {
		f.RenamedOpt = y.RenamedOpt
	}

	if y.RenamedPostgresOpt != nil {
		f.RenamedPostgresOpt = y.RenamedPostgresOpt
	}
	if y.IgnoredRestOpt != nil {
		f.IgnoredRestOpt = y.IgnoredRestOpt
	}
	if y.RenamedRestOpt != nil {
		f.RenamedRestOpt = y.RenamedRestOpt
	}
	if y.IgnoredMongoOpt != nil {
		f.IgnoredMongoOpt = y.IgnoredMongoOpt
	}
	if y.RenamedMongoOpt != nil {
		f.RenamedMongoOpt = y.RenamedMongoOpt
	}
	if y.BsonStringOidOpt != nil {
		f.BsonStringOidOpt = y.BsonStringOidOpt
	}
	if y.BsonBytesOidOpt != nil {
		f.BsonBytesOidOpt = y.BsonBytesOidOpt
	}
	return f
}

// SingleScanner is an autogenerated struct that
// is used to parse query results.
type SingleScanner struct {
	ScalarInt32    sql1.NullInt32           `db:"scalar_int32"`
	ScalarInt64    sql1.NullInt64           `db:"scalar_int64"`
	ScalarFloat32  sql1.NullFloat64         `db:"scalar_float32"`
	ScalarFloat64  sql1.NullFloat64         `db:"scalar_float64"`
	ScalarString   sql1.NullString          `db:"scalar_string"`
	ScalarBytes    []byte                   `db:"scalar_bytes"`
	ScalarBool     sql1.NullBool            `db:"scalar_bool"`
	ManyScalarBool []bool                   `db:"many_scalar_bool"`
	ScalarEnum     sql1.NullInt32           `db:"scalar_enum"`
	ObjMessage     *single.Single_Message   `db:"obj_message"`
	ManyObjMessage []*single.Single_Message `db:"many_obj_message"`

	Renamed sql1.NullString `db:"aliased"`

	RenamedPostgres  sql1.NullString        `db:"aliased_postgres"`
	IgnoredRest      sql1.NullString        `db:"ignored_rest"`
	RenamedRest      sql1.NullString        `db:"renamed_rest"`
	IgnoredMongo     sql1.NullString        `db:"ignored_mongo"`
	RenamedMongo     sql1.NullString        `db:"renamed_mongo"`
	BsonStringOid    sql1.NullString        `db:"bson_string_oid"`
	BsonBytesOid     []byte                 `db:"bson_bytes_oid"`
	ScalarInt32Opt   *int32                 `db:"scalar_int32_opt"`
	ScalarInt64Opt   *int64                 `db:"scalar_int64_opt"`
	ScalarFloat32Opt *float32               `db:"scalar_float32_opt"`
	ScalarFloat64Opt *float64               `db:"scalar_float64_opt"`
	ScalarStringOpt  *string                `db:"scalar_string_opt"`
	ScalarBytesOpt   []byte                 `db:"scalar_bytes_opt"`
	ScalarBoolOpt    *bool                  `db:"scalar_bool_opt"`
	ScalarEnumOpt    sql1.NullInt32         `db:"scalar_enum_opt"`
	ObjMessageOpt    *single.Single_Message `db:"obj_message_opt"`

	RenamedOpt *string `db:"aliased_opt"`

	RenamedPostgresOpt *string `db:"aliased_postgres_opt"`
	IgnoredRestOpt     *string `db:"ignored_rest_opt"`
	RenamedRestOpt     *string `db:"renamed_rest_opt"`
	IgnoredMongoOpt    *string `db:"ignored_mongo_opt"`
	RenamedMongoOpt    *string `db:"renamed_mongo_opt"`
	BsonStringOidOpt   *string `db:"bson_string_oid_opt"`
	BsonBytesOidOpt    []byte  `db:"bson_bytes_oid_opt"`
}

// Single returns a new single.Single populated with scanned values.
func (x *SingleScanner) Single() *single.Single {
	y := &single.Single{}

	if x.ScalarInt32.Valid {
		y.ScalarInt32 = x.ScalarInt32.Int32
	}
	if x.ScalarInt64.Valid {
		y.ScalarInt64 = x.ScalarInt64.Int64
	}
	if x.ScalarFloat32.Valid {
		y.ScalarFloat32 = float32(x.ScalarFloat32.Float64)
	}
	if x.ScalarFloat64.Valid {
		y.ScalarFloat64 = x.ScalarFloat64.Float64
	}
	if x.ScalarString.Valid {
		y.ScalarString = x.ScalarString.String
	}
	if x.ScalarBytes.Valid {
		y.ScalarBytes = x.ScalarBytes
	}
	if x.ScalarBool.Valid {
		y.ScalarBool = x.ScalarBool.Bool
	}
	if x.ManyScalarBool.Valid {
		y.ManyScalarBool = x.ManyScalarBool
	}
	if x.ScalarEnum.Valid {
		y.ScalarEnum = single.Single_Enum(x.ScalarEnum.Int32)
	}
	y.ObjMessage = x.ObjMessage
	y.ManyObjMessage = x.ManyObjMessage

	if x.Renamed.Valid {
		y.Renamed = x.Renamed.String
	}

	if x.RenamedPostgres.Valid {
		y.RenamedPostgres = x.RenamedPostgres.String
	}
	if x.IgnoredRest.Valid {
		y.IgnoredRest = x.IgnoredRest.String
	}
	if x.RenamedRest.Valid {
		y.RenamedRest = x.RenamedRest.String
	}
	if x.IgnoredMongo.Valid {
		y.IgnoredMongo = x.IgnoredMongo.String
	}
	if x.RenamedMongo.Valid {
		y.RenamedMongo = x.RenamedMongo.String
	}
	if x.BsonStringOid.Valid {
		y.BsonStringOid = x.BsonStringOid.String
	}
	if x.BsonBytesOid.Valid {
		y.BsonBytesOid = x.BsonBytesOid
	}
	if x.ScalarInt32Opt.Valid {
		y.ScalarInt32Opt = x.ScalarInt32Opt
	}
	if x.ScalarInt64Opt.Valid {
		y.ScalarInt64Opt = x.ScalarInt64Opt
	}
	if x.ScalarFloat32Opt.Valid {
		y.ScalarFloat32Opt = x.ScalarFloat32Opt
	}
	if x.ScalarFloat64Opt.Valid {
		y.ScalarFloat64Opt = x.ScalarFloat64Opt
	}
	if x.ScalarStringOpt.Valid {
		y.ScalarStringOpt = x.ScalarStringOpt
	}
	if x.ScalarBytesOpt.Valid {
		y.ScalarBytesOpt = x.ScalarBytesOpt
	}
	if x.ScalarBoolOpt.Valid {
		y.ScalarBoolOpt = x.ScalarBoolOpt
	}
	if x.ScalarEnumOpt.Valid {
		y.ScalarEnumOpt = *single.Single_Enum(x.ScalarEnumOpt.Int32)
	}
	y.ObjMessageOpt = x.ObjMessageOpt

	if x.RenamedOpt.Valid {
		y.RenamedOpt = x.RenamedOpt
	}

	if x.RenamedPostgresOpt.Valid {
		y.RenamedPostgresOpt = x.RenamedPostgresOpt
	}
	if x.IgnoredRestOpt.Valid {
		y.IgnoredRestOpt = x.IgnoredRestOpt
	}
	if x.RenamedRestOpt.Valid {
		y.RenamedRestOpt = x.RenamedRestOpt
	}
	if x.IgnoredMongoOpt.Valid {
		y.IgnoredMongoOpt = x.IgnoredMongoOpt
	}
	if x.RenamedMongoOpt.Valid {
		y.RenamedMongoOpt = x.RenamedMongoOpt
	}
	if x.BsonStringOidOpt.Valid {
		y.BsonStringOidOpt = x.BsonStringOidOpt
	}
	if x.BsonBytesOidOpt.Valid {
		y.BsonBytesOidOpt = x.BsonBytesOidOpt
	}
	return y
}

// SingleWriter is an autogenerated struct that is used to supply values to write queries.
type SingleWriter struct {
	ScalarInt32    int32                    `db:"scalar_int32"`
	ScalarInt64    int64                    `db:"scalar_int64"`
	ScalarFloat32  float32                  `db:"scalar_float32"`
	ScalarFloat64  float64                  `db:"scalar_float64"`
	ScalarString   string                   `db:"scalar_string"`
	ScalarBytes    []byte                   `db:"scalar_bytes"`
	ScalarBool     bool                     `db:"scalar_bool"`
	ManyScalarBool []bool                   `db:"many_scalar_bool"`
	ScalarEnum     single.Single_Enum       `db:"scalar_enum"`
	ObjMessage     *single.Single_Message   `db:"obj_message"`
	ManyObjMessage []*single.Single_Message `db:"many_obj_message"`

	Renamed string `db:"aliased"`

	RenamedPostgres  string                 `db:"aliased_postgres"`
	IgnoredRest      string                 `db:"ignored_rest"`
	RenamedRest      string                 `db:"renamed_rest"`
	IgnoredMongo     string                 `db:"ignored_mongo"`
	RenamedMongo     string                 `db:"renamed_mongo"`
	BsonStringOid    string                 `db:"bson_string_oid"`
	BsonBytesOid     []byte                 `db:"bson_bytes_oid"`
	ScalarInt32Opt   *int32                 `db:"scalar_int32_opt"`
	ScalarInt64Opt   *int64                 `db:"scalar_int64_opt"`
	ScalarFloat32Opt *float32               `db:"scalar_float32_opt"`
	ScalarFloat64Opt *float64               `db:"scalar_float64_opt"`
	ScalarStringOpt  *string                `db:"scalar_string_opt"`
	ScalarBytesOpt   []byte                 `db:"scalar_bytes_opt"`
	ScalarBoolOpt    *bool                  `db:"scalar_bool_opt"`
	ScalarEnumOpt    *single.Single_Enum    `db:"scalar_enum_opt"`
	ObjMessageOpt    *single.Single_Message `db:"obj_message_opt"`

	RenamedOpt *string `db:"aliased_opt"`

	RenamedPostgresOpt *string `db:"aliased_postgres_opt"`
	IgnoredRestOpt     *string `db:"ignored_rest_opt"`
	RenamedRestOpt     *string `db:"renamed_rest_opt"`
	IgnoredMongoOpt    *string `db:"ignored_mongo_opt"`
	RenamedMongoOpt    *string `db:"renamed_mongo_opt"`
	BsonStringOidOpt   *string `db:"bson_string_oid_opt"`
	BsonBytesOidOpt    []byte  `db:"bson_bytes_oid_opt"`
}

func singleWriterFromGeneric(y *single.Single) *SingleWriter {
	x := &SingleWriter{}
	x.ScalarInt32 = y.ScalarInt32
	x.ScalarInt64 = y.ScalarInt64
	x.ScalarFloat32 = y.ScalarFloat32
	x.ScalarFloat64 = y.ScalarFloat64
	x.ScalarString = y.ScalarString
	x.ScalarBytes = y.ScalarBytes
	x.ScalarBool = y.ScalarBool
	x.ManyScalarBool = y.ManyScalarBool
	x.ScalarEnum = y.ScalarEnum
	x.ObjMessage = y.ObjMessage
	x.ManyObjMessage = y.ManyObjMessage

	x.Renamed = y.Renamed

	x.RenamedPostgres = y.RenamedPostgres
	x.IgnoredRest = y.IgnoredRest
	x.RenamedRest = y.RenamedRest
	x.IgnoredMongo = y.IgnoredMongo
	x.RenamedMongo = y.RenamedMongo
	x.BsonStringOid = y.BsonStringOid
	x.BsonBytesOid = y.BsonBytesOid
	x.ScalarInt32Opt = y.ScalarInt32Opt
	x.ScalarInt64Opt = y.ScalarInt64Opt
	x.ScalarFloat32Opt = y.ScalarFloat32Opt
	x.ScalarFloat64Opt = y.ScalarFloat64Opt
	x.ScalarStringOpt = y.ScalarStringOpt
	x.ScalarBytesOpt = y.ScalarBytesOpt
	x.ScalarBoolOpt = y.ScalarBoolOpt
	x.ScalarEnumOpt = y.ScalarEnumOpt
	x.ObjMessageOpt = y.ObjMessageOpt

	x.RenamedOpt = y.RenamedOpt

	x.RenamedPostgresOpt = y.RenamedPostgresOpt
	x.IgnoredRestOpt = y.IgnoredRestOpt
	x.RenamedRestOpt = y.RenamedRestOpt
	x.IgnoredMongoOpt = y.IgnoredMongoOpt
	x.RenamedMongoOpt = y.RenamedMongoOpt
	x.BsonStringOidOpt = y.BsonStringOidOpt
	x.BsonBytesOidOpt = y.BsonBytesOidOpt
	return x
}

// SingleConfig is a struct that can be used to configure a SingleCollection
type SingleConfig struct {
	TableName string `envconfig:"table"`
}

// SingleQueryTemplateProvider is an interface that returns the query templated that should be executed
// to generate the queries that the collection will use.
//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 . SingleQueryTemplateProvider
type SingleQueryTemplateProvider interface {
	Insert() string
	Upsert() string
	Update() string
	All() string
	ById() string
	OneParam() string
	MultipleParam() string
	MessageParam() string
	WithComparator() string
	WithRest() string
	ProviderStubOnly() string
	NonFieldOnly() string
}

// SingleQueries provides auto-generated queries when possible. This is not gauranteed to be a complete
// implementation of the interface. This should be used as a base for the actual query provider used.
type SingleQueries struct {
}

// Insert implements SingleQueryTemplateProvider.Insert.
func (x *SingleQueries) Insert() string {
	return `INSERT INTO {{ .table }}({{ .fields }}) VALUES({{ .writeFields }});`
}

// Upsert implements SingleQueryTemplateProvider.Upsert.
func (x *SingleQueries) Upsert() string {
	return `INSERT INTO {{ .table }}({{ .fields }}) VALUES({{ .writeFields }});`
}

// Update implements SingleQueryTemplateProvider.Update.
func (x *SingleQueries) Update() string {
	return `UPDATE {{ .table }} SET {{ .updates }}{{ if .clause }} WHERE {{ .clause }}{{ end }};`
}

// All implements SingleQueryTemplateProvider.All.
func (x *SingleQueries) All() string {
	return `SELECT {{ .fields }} FROM {{ .table }};`
}

//ByIdimplements SingleQueryTemplateProvider.ById.
func (x *SingleQueries) ById() string {
	return `SELECT {{ .fields }} FROM {{ .table }} WHERE
			1 = 1 AND
				bson_string_oid = :bson_string_oid;`
}

//OneParamimplements SingleQueryTemplateProvider.OneParam.
func (x *SingleQueries) OneParam() string {
	return `SELECT {{ .fields }} FROM {{ .table }} WHERE
			1 = 1 AND
				scalar_int32 = :scalar_int32;`
}

//MultipleParamimplements SingleQueryTemplateProvider.MultipleParam.
func (x *SingleQueries) MultipleParam() string {
	return `SELECT {{ .fields }} FROM {{ .table }} WHERE
			1 = 1 AND
				scalar_int32 = :scalar_int32 AND
				scalar_int64 = :scalar_int64 AND
				scalar_float32 = :scalar_float32;`
}

//MessageParamimplements SingleQueryTemplateProvider.MessageParam.
func (x *SingleQueries) MessageParam() string {
	return `SELECT {{ .fields }} FROM {{ .table }} WHERE
			1 = 1 AND
				obj_message = :obj_message;`
}

//WithComparatorimplements SingleQueryTemplateProvider.WithComparator.
func (x *SingleQueries) WithComparator() string {
	return `SELECT {{ .fields }} FROM {{ .table }} WHERE
			1 = 1 AND
				scalar_int32 > :scalar_int32;`
}

//WithRestimplements SingleQueryTemplateProvider.WithRest.
func (x *SingleQueries) WithRest() string {
	return `SELECT {{ .fields }} FROM {{ .table }} WHERE
			1 = 1 AND
				scalar_int32 = :scalar_int32 AND
				scalar_int64 = :scalar_int64 AND
				scalar_float32 = :scalar_float32 AND
				scalar_float64 = :scalar_float64;`
}

//NonFieldOnlyimplements SingleQueryTemplateProvider.NonFieldOnly.
func (x *SingleQueries) NonFieldOnly() string {
	return `SELECT {{ .fields }} FROM {{ .table }} WHERE
			1 = 1 AND
				kind = :kind;`
}
