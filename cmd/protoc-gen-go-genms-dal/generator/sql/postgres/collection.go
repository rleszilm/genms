package postgres

import (
	"bytes"
	"fmt"
	"path"
	"strings"
	"text/template"

	"github.com/go-test/deep"
	"github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/annotations"
	protocgenlib "github.com/rleszilm/genms/internal/protoc-gen-lib"
	"golang.org/x/tools/imports"
	"google.golang.org/protobuf/compiler/protogen"
)

// Collection is a struct that generates a colelction file.
type Collection struct {
	File    *File
	Message *Message
	Fields  *Fields
	Queries *Queries
	Opts    *annotations.DalOptions

	plugin   *protogen.Plugin
	filename string
}

// NewCollection returns a new collection renderer.
func NewCollection(plugin *protogen.Plugin, file *protogen.File, msg *protogen.Message, opts *annotations.DalOptions) *Collection {
	base := path.Base(file.GeneratedFilenamePrefix)
	dir := path.Dir(file.GeneratedFilenamePrefix)
	filename := path.Join(dir, fmt.Sprintf("dal/sql/postgres/%s.genms.dal.%s.go", base, strings.ToLower(msg.GoIdent.GoName)))
	outfile := plugin.NewGeneratedFile(filename, ".")

	cfile := NewFile(outfile, file)
	cmsg := NewMessage(cfile, msg)
	cfields := NewFields(cmsg)
	cqueries := NewQueries(cfile, cfields, opts)

	return &Collection{
		File:     cfile,
		Message:  cmsg,
		Fields:   cfields,
		Queries:  cqueries,
		Opts:     opts,
		plugin:   plugin,
		filename: filename,
	}
}

// GenerateCollection generates the dal interface for the collection
func GenerateCollection(plugin *protogen.Plugin, file *protogen.File, msg *protogen.Message, opts *annotations.DalOptions) error {
	c := NewCollection(plugin, file, msg, opts)
	return c.render()
}

func (c *Collection) render() error {
	steps := []func() error{
		c.definePackage,
		c.defineCollection,
		c.defineService,
		c.defineDefaultQueries,
		c.defineQueries,
		c.defineNewCollection,
		c.defineInternalStructs,
		c.defineConfig,
		c.defineTemplateProvider,
	}

	for _, s := range steps {
		if err := s(); err != nil {
			return err
		}
	}

	outfile := c.File.Outfile()
	original, err := outfile.Content()
	if err != nil {
		return err
	}
	formatted, err := imports.Process(c.filename, original, nil)

	if diff := deep.Equal(original, formatted); diff != nil {
		formattedOutfile := c.plugin.NewGeneratedFile(c.filename, ".")
		if _, err := formattedOutfile.Write(formatted); err != nil {
			return err
		}
		outfile.Skip()
	}

	return nil
}

func (c *Collection) definePackage() error {
	tmplSrc := `// Package {{ .File.PostgresPackageName }} is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package {{ .File.PostgresPackageName }}
`

	tmpl, err := template.New("definePostgresPackage").
		Funcs(template.FuncMap{}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, c); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineCollection() error {
	tmplSrc := `// {{ .C.Message.Name }}Collection is an autogenerated implementation of {{ .C.Message.QualifiedDalKind }}Collection.
type {{ .C.Message.Name }}Collection struct {
	{{ .P.Collection }}.Unimplemented{{ .C.Message.Name }}Collection

	name string

	db {{ .P.GenmsSQL }}.DB
	config *{{ .C.Message.Name }}Config

	execInsert string
	execUpsert string
	queryAll string

	execUpdateTmpl *{{ .P.Template }}.Template

	{{ range $qn := .C.Queries.Names -}}
		{{- $q := $.C.Queries.ByName $qn -}}
		{{- if $q.QueryProvided -}}
			query{{ ToTitleCase $q.Name }} string
		{{- end }}
	{{ end -}}
}
`

	tmpl, err := template.New("definePostgresCollection").
		Funcs(template.FuncMap{
			"ToTitleCase": protocgenlib.ToTitleCase,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Collection": c.File.QualifiedPackageName(c.File.DalPackagePath()),
		"GenmsSQL":   c.File.QualifiedPackageName("github.com/rleszilm/genms/sql"),
		"Template":   c.File.QualifiedPackageName("text/template"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineService() error {
	tmplSrc := `// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *{{ .C.Message.Name }}Collection) Initialize(_ {{ .P.Context }}.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *{{ .C.Message.Name }}Collection) Shutdown(_ {{ .P.Context }}.Context) error {
	return nil
}

// String returns the name of the Collection.
func (x *{{ .C.Message.Name }}Collection) String() string {
	{{- $pkg := .C.File.PostgresPackageName -}}
	if x.name != "" {
		return "{{ ToDashCase $pkg }}-{{ ToDashCase .C.Message.Name }}-" + x.name
	}
	return "{{ ToDashCase $pkg }}-{{ ToDashCase .C.Message.Name }}"
}

// NameOf returns the name of the Collection.
func (x *{{ .C.Message.Name }}Collection) NameOf() string {
	return x.String()
}
`

	tmpl, err := template.New("definePostgresService").
		Funcs(template.FuncMap{
			"ToDashCase": protocgenlib.ToDashCase,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Context": c.File.QualifiedPackageName("context"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineDefaultQueries() error {
	tmplSrc := `// DoInsert provides the base logic for {{ .C.Message.QualifiedDalKind }}Collection.Insert.
// The user should use this as a base for {{ .C.Message.QualifiedDalKind }}Collection.Insert, only having to add
// code that interprets the returned values.
func (x *{{ .C.Message.Name }}Collection) DoInsert(ctx {{ .P.Context }}.Context, arg *{{ .C.Message.QualifiedKind }}) ({{ .P.SQL }}.Result, error) {
	start := {{ .P.Time }}.Now()
	ctx, _ = {{ .P.Tag }}.New(ctx,
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagCollection, "{{ ToSnakeCase .C.Message.Name }}"),
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagInstance, x.name),
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagQuery, "insert"),
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagDriver, "postgres"),
	)
	{{ .P.Stats }}.Record(ctx, {{ .P.GenMSSql }}.MeasureInflight.M(1))
	defer func() {
		stop := {{ .P.Time }}.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64({{ .P.Time }}.Millisecond)
		{{ .P.Stats }}.Record(ctx, {{ .P.GenMSSql }}.MeasureLatency.M(dur), {{ .P.GenMSSql }}.MeasureInflight.M(-1))
	}()

	res, err := x.db.ExecWithReplacements(ctx, x.execInsert, {{ ToSnakeCase .C.Message.Name }}WriterFromGeneric(arg))
	if err != nil {
		{{ .P.GenMSSql }}.Logs().Error("postgres: could not execute insert - ", err)
		{{ .P.Stats }}.Record(ctx, {{ .P.GenMSSql }}.MeasureError.M(1))
		return nil, err
	}

	return res, err
}

// DoUpsert provides the base logic for {{ .C.Message.QualifiedDalKind }}Collection.Upsert.
// The user should use this as a base for {{ .C.Message.QualifiedDalKind }}Collection.Upsert, only having to add
// code that interprets the returned values.
func (x *{{ .C.Message.Name }}Collection) DoUpsert(ctx {{ .P.Context }}.Context, arg *{{ .C.Message.QualifiedKind }}) ({{ .P.SQL }}.Result, error) {
	start := {{ .P.Time }}.Now()
	ctx, _ = {{ .P.Tag }}.New(ctx,
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagCollection, "{{ ToSnakeCase .C.Message.Name }}"),
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagInstance, x.name),
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagQuery, "upsert"),
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagDriver, "postgres"),
	)
	{{ .P.Stats }}.Record(ctx, {{ .P.GenMSSql }}.MeasureInflight.M(1))
	defer func() {
		stop := {{ .P.Time }}.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64({{ .P.Time }}.Millisecond)
		{{ .P.Stats }}.Record(ctx, {{ .P.GenMSSql }}.MeasureLatency.M(dur), {{ .P.GenMSSql }}.MeasureInflight.M(-1))
	}()

	res, err := x.db.ExecWithReplacements(ctx, x.execUpsert, {{ ToSnakeCase .C.Message.Name }}WriterFromGeneric(arg))
	if err != nil {
		{{ .P.GenMSSql }}.Logs().Error("postgres: could not execute upsert - ", err)
		{{ .P.Stats }}.Record(ctx, {{ .P.GenMSSql }}.MeasureError.M(1))
		return nil, err
	}

	return res, err
}

// DoUpdate provides the base logic for {{ .C.Message.QualifiedDalKind }}Collection.Upsert.
// The user should use this as a base for {{ .C.Message.QualifiedDalKind }}Collection.Upsert, only having to add
// code that interprets the returned values.
func (x *{{ .C.Message.Name }}Collection) DoUpdate(ctx {{ .P.Context }}.Context, fvs *{{ .C.Message.QualifiedDalKind }}FieldValues, clause string) ({{ .P.SQL }}.Result, error) {
	start := {{ .P.Time }}.Now()
	ctx, _ = {{ .P.Tag }}.New(ctx,
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagCollection, "{{ ToSnakeCase .C.Message.Name }}"),
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagInstance, x.name),
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagQuery, "update"),
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagDriver, "postgres"),
	)
	{{ .P.Stats }}.Record(ctx, {{ .P.GenMSSql }}.MeasureInflight.M(1))
	defer func() {
		stop := {{ .P.Time }}.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64({{ .P.Time }}.Millisecond)
		{{ .P.Stats }}.Record(ctx, {{ .P.GenMSSql }}.MeasureLatency.M(dur), {{ .P.GenMSSql }}.MeasureInflight.M(-1))
	}()

	updates := []string{}
	{{ range $name := .C.Fields.Names -}}
		{{- $f := ($.C.Fields.ByName $name) -}}
		{{- if not $f.Ignore }}
			if fvs.{{ ToTitleCase $f.Name }} != nil {
				updates = append(updates, "{{ $f.QueryName }} = :{{ $f.QueryName }}")
			}
		{{ end -}}
	{{ end -}}

	buf := &{{ .P.Bytes }}.Buffer{}
	if err := x.execUpdateTmpl.Execute(buf, map[string]interface{}{
		"clause": clause,
		"table": x.config.TableName,
		"updates": strings.Join(updates, ", "),
	}); err != nil {
		{{ .P.GenMSSql }}.Logs().Error("postgres: could not format update - ", err)
		{{ .P.Stats }}.Record(ctx, {{ .P.GenMSSql }}.MeasureError.M(1))
		return nil, err
	}

	res, err := x.db.ExecWithReplacements(ctx, string(buf.Bytes()), {{ ToSnakeCase .C.Message.Name }}FieldValuesFromGeneric(fvs))
	if err != nil {
		{{ .P.GenMSSql }}.Logs().Error("could not execute update:", err)
		{{ .P.Stats }}.Record(ctx, {{ .P.GenMSSql }}.MeasureError.M(1))
		return nil, err
	}

	return res, err
}

// All implements {{ .C.Message.QualifiedDalKind }}Collection.All
func (x *{{ .C.Message.Name }}Collection) All(ctx {{ .P.Context }}.Context) ([]*{{ .C.Message.QualifiedKind }}, error) {
	return x.find(ctx, "all", x.queryAll, map[string]interface{}{})
}

// Filter implements {{ .C.Message.QualifiedDalKind }}Collection.Filter
func (x *{{ .C.Message.Name }}Collection) Filter(ctx {{ .P.Context }}.Context, fvs *{{ .C.Message.QualifiedDalKind }}FieldValues) ([]*{{ .C.Message.QualifiedKind }}, error) {
	query := "SELECT {{ .V.QueryFields }} FROM " + x.config.TableName
	
	fields := []string{}
	{{ range $fn := .C.Fields.Names -}}
		{{- $f := ($.C.Fields.ByName $fn) -}}
		{{- if not $f.Ignore -}}
			if fvs.{{ ToTitleCase $f.Name }} != nil {
				fields = append(fields, "{{ $f.QueryName }} = :{{ $f.QueryName }}")
			}
		{{- end }}
	{{ end -}}

	if len(fields) > 0 {
		query = {{ .P.Fmt }}.Sprintf("%s WHERE %s", query, {{ .P.Strings }}.Join(fields, " AND "))
	}

	return x.find(ctx, "filter", query, {{ ToSnakeCase .C.Message.Name }}FieldValuesFromGeneric(fvs))
}

func (x *{{ .C.Message.Name }}Collection) find(ctx {{ .P.Context }}.Context, label string, query string, fvs interface{}) ([]*{{ .C.Message.QualifiedKind }}, error) {
	start := {{ .P.Time }}.Now()
	ctx, _ = {{ .P.Tag }}.New(ctx,
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagCollection, "{{ ToSnakeCase .C.Message.Name }}"),
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagInstance, x.name),
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagQuery, label),
		{{ .P.Tag }}.Upsert({{ .P.GenMSSql }}.TagDriver, "postgres"),
	)
	{{ .P.Stats }}.Record(ctx, {{ .P.GenMSSql }}.MeasureInflight.M(1))
	defer func() {
		stop := {{ .P.Time }}.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64({{ .P.Time }}.Millisecond)
		{{ .P.Stats }}.Record(ctx, {{ .P.GenMSSql }}.MeasureLatency.M(dur), {{ .P.GenMSSql }}.MeasureInflight.M(-1))
	}()

	rows, err := x.db.QueryWithReplacements(ctx, query, fvs)
	if err != nil {
		{{ .P.GenMSSql }}.Logs().Errorf("could not execute %s - %v", label, err)
		{{ .P.Stats }}.Record(ctx, {{ .P.GenMSSql }}.MeasureError.M(1))
		return nil, err
	}
	defer rows.Close()

	{{ .C.Message.Name }}s := []*{{ .C.Message.QualifiedKind }}{}
	for rows.Next() {
		obj := &{{ .C.Message.Name }}Scanner{}
		if err = rows.StructScan(obj); err != nil {
			{{ .P.GenMSSql }}.Logs().Errorf("could not parse %s - %v", label, err)
			{{ .P.Stats }}.Record(ctx, {{ .P.GenMSSql }}.MeasureError.M(1))
			return nil, err
		}
		{{ .C.Message.Name }}s = append({{ .C.Message.Name }}s, obj.{{ .C.Message.Name }}())
	}
	return {{ .C.Message.Name }}s, nil
}
`

	tmpl, err := template.New("definePostgresDefaultQueries").
		Funcs(template.FuncMap{
			"ToCamelCase": protocgenlib.ToCamelCase,
			"ToSnakeCase": protocgenlib.ToSnakeCase,
			"ToTitleCase": protocgenlib.ToTitleCase,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Bytes":    c.File.QualifiedPackageName("bytes"),
		"Context":  c.File.QualifiedPackageName("context"),
		"Fmt":      c.File.QualifiedPackageName("fmt"),
		"GenMSSql": c.File.QualifiedPackageName("github.com/rleszilm/genms/sql"),
		"SQL":      c.File.QualifiedPackageName("database/sql"),
		"Stats":    c.File.QualifiedPackageName("go.opencensus.io/stats"),
		"Strings":  c.File.QualifiedPackageName("strings"),
		"Tag":      c.File.QualifiedPackageName("go.opencensus.io/tag"),
		"Time":     c.File.QualifiedPackageName("time"),
	}

	fields := []string{}
	queryFields := []string{}
	for _, n := range c.Fields.Names() {
		f := c.Fields.ByName(n)
		fields = append(fields, f.Name())
		queryFields = append(queryFields, f.QueryName())
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
		"V": map[string]string{
			"Fields":      strings.Join(fields, ", "),
			"QueryFields": strings.Join(queryFields, ", "),
		},
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineQueries() error {
	tmplSrc := `{{ range $qn := .C.Queries.Names }}
{{- $q := ($.C.Queries.ByName $qn) -}}
{{- if $q.QueryProvided }}
	// {{ ToTitleCase $q.Name }} implements {{ $.C.Message.QualifiedDalKind }}Collection.{{ ToTitleCase $q.Name }}
	func (x *{{ $.C.Message.Name }}Collection){{ ToTitleCase $q.Name }}(ctx {{ $.P.Context }}.Context
		{{- range $a := $q.Args -}}
			{{- $arg := (Arg $.C.File $.C.Fields $a) -}}
			, {{ ToSnakeCase $arg.Name }} {{ $arg.QualifiedKind }}
		{{- end -}}
	) ([]*{{ $.C.Message.QualifiedKind }}, error) {
		fvs := map[string]interface{}{
			{{- range $a := $q.Args -}}
				{{- $arg := (Arg $.C.File $.C.Fields $a) -}}
				"{{ $arg.QueryName }}": {{ $arg.ToRef }}{{ ToSnakeCase $arg.Name }},
			{{- end }}
		}
		return x.find(ctx, "{{ ToSnakeCase $q.Name }}", x.query{{ ToTitleCase $q.Name }}, fvs)
	}
{{- end -}}
{{- end }}
`

	tmpl, err := template.New("definePostgresQueries").
		Funcs(template.FuncMap{
			"Arg":         NewArg,
			"ToSnakeCase": protocgenlib.ToSnakeCase,
			"ToTitleCase": protocgenlib.ToTitleCase,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Context": c.File.QualifiedPackageName("context"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineNewCollection() error {
	tmplSrc := `// New{{ .C.Message.Name }}Collection returns a new {{ .C.Message.Name }}Collection.
func New{{ .C.Message.Name }}Collection(instance string, db {{ .P.GenmsSQL }}.DB, queries {{ .C.Message.Name }}QueryTemplateProvider, config *{{ .C.Message.Name }}Config) (*{{ .C.Message.Name }}Collection, error) {
	coll := &{{ .C.Message.Name }}Collection{
		name: instance,
		db: db,
		config: config,
	}

	queryReplacements := map[string]string{
		"table": config.TableName,
		"fields": "{{ .V.QueryFields }}",
		"writeFields": "{{ .V.WriteFields }}",
	}

	// generate Insert exec
	execInsert, err := {{ .P.Dal }}.RenderQuery("{{ .C.Message.QualifiedDalKind }}-exec-insert", queries.Insert(), queryReplacements)
	if err != nil {
		return nil, err
	}	
	coll.execInsert = execInsert

	// generate Upsert exec
	execUpsert, err := {{ .P.Dal }}.RenderQuery("{{ .C.Message.QualifiedDalKind }}-exec-upsert", queries.Upsert(), queryReplacements)
	if err != nil {
		return nil, err
	}	
	coll.execUpsert = execUpsert
	
	execUpdateTmpl, err := {{ .P.Template }}.New("{{ .C.Message.QualifiedDalKind }}-exec-update").
		Funcs(template.FuncMap{}).
		Parse(queries.Update())
	
	if err != nil {
		return nil, err
	}
	coll.execUpdateTmpl = execUpdateTmpl

	// generate All query
	queryAll, err := {{ .P.Dal }}.RenderQuery("{{ .C.Message.QualifiedDalKind }}-query-all", queries.All(), queryReplacements)
	if err != nil {
		return nil, err
	}	
	coll.queryAll = queryAll

	{{ range $qn := .C.Queries.Names -}}
		{{- $q := ($.C.Queries.ByName $qn) -}}
		{{- if $q.QueryProvided -}}
			// generate {{ ToTitleCase $qn }} query
			query{{ ToTitleCase $qn }}, err := {{ $.P.Dal }}.RenderQuery("{{ $.C.Message.QualifiedDalKind }}-query-{{ ToSnakeCase $qn }}", queries.{{ ToTitleCase $qn }}(), queryReplacements)
			if err != nil {
				return nil, err
			}	
			coll.query{{ ToTitleCase $qn }} = query{{ ToTitleCase $qn }}
		{{ end }}
	{{ end -}}

	return coll, nil
}
`

	tmpl, err := template.New("definePostgresNewCollection").
		Funcs(template.FuncMap{
			"ToSnakeCase": protocgenlib.ToSnakeCase,
			"ToTitleCase": protocgenlib.ToTitleCase,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Collection": c.File.QualifiedPackageName(c.File.PackagePath()),
		"Dal":        c.File.QualifiedPackageName("github.com/rleszilm/genms/dal"),
		"GenmsSQL":   c.File.QualifiedPackageName("github.com/rleszilm/genms/sql"),
		"Template":   c.File.QualifiedPackageName("text/template"),
	}

	fields := []string{}
	queryFields := []string{}
	writeFields := []string{}
	for _, n := range c.Fields.Names() {
		f := c.Fields.ByName(n)
		fields = append(fields, f.Name())
		queryFields = append(queryFields, f.QueryName())
		writeFields = append(writeFields, ":"+f.QueryName())
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
		"V": map[string]string{
			"Fields":      strings.Join(fields, ", "),
			"QueryFields": strings.Join(queryFields, ", "),
			"WriteFields": strings.Join(writeFields, ", "),
		},
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineInternalStructs() error {
	tmplSrc := `// {{ .C.Message.Name }}FieldValues is an autogenerated struct that is used in generic {{ .C.Message.Name }} queries.
type {{ .C.Message.Name }}FieldValues struct {
	{{ range $n := .C.Fields.Names -}}
		{{- $f := ($.C.Fields.ByName $n) -}}
		{{- if not $f.Ignore -}}
			{{ ToTitleCase $f.Name }} {{- if not $f.IsRef -}}*{{- end -}}{{ $f.QualifiedKind }} ` + "`" + `db:"{{ $f.QueryName }}"` + "`" + `
		{{- end }}
	{{ end -}}
}

func {{ ToSnakeCase .C.Message.Name }}FieldValuesFromGeneric(y *{{ .C.Message.QualifiedDalKind }}FieldValues) *{{ .C.Message.Name }}FieldValues {
	f := &{{ .C.Message.Name }}FieldValues{}
	{{ range $n := .C.Fields.Names -}}
		{{- $f := ($.C.Fields.ByName $n) -}}
		{{- if not $f.Ignore -}}
			if y.{{ ToTitleCase $f.Name }} != nil {
				f.{{ ToTitleCase $f.Name }} = y.{{ ToTitleCase $f.Name }}
			}
		{{- end }}
	{{ end -}}
	return f
}

// {{ .C.Message.Name }}Scanner is an autogenerated struct that
// is used to parse query results.
type {{ .C.Message.Name }}Scanner struct {
	{{ range $n := .C.Fields.Names -}}
		{{- $f := ($.C.Fields.ByName $n) -}}
		{{- if not $f.Ignore -}}
			{{ ToTitleCase $f.Name }} {{ $f.SQLNilKind }} ` + "`" + `db:"{{ $f.QueryName }}"` + "`" + `
		{{- end }}
	{{ end -}}
}

// {{ .C.Message.Name }} returns a new {{ .C.Message.QualifiedKind }} populated with scanned values.
func (x *{{ .C.Message.Name }}Scanner) {{ .C.Message.Name }}() *{{ .C.Message.QualifiedKind }} {
	y := &{{ .C.Message.QualifiedKind }}{}

	{{ range $n := .C.Fields.Names -}}
		{{- $f := ($.C.Fields.ByName $n) -}}
		{{- if not $f.Ignore -}}
			{{- if $f.HasSQLNil -}}
				if x.{{ ToTitleCase $f.Name }}.Valid {
					y.{{ ToTitleCase $f.Name }} = {{ $f.ValueFromSQLValue "x" }}
				}
			{{- else -}}
				y.{{ ToTitleCase $f.Name }} = {{ $f.ValueFromSQLValue "x" }}
			{{- end -}}
		{{- end }}
	{{ end -}}
	return y
}

// {{ .C.Message.Name }}Writer is an autogenerated struct that is used to supply values to write queries.
type {{ .C.Message.Name }}Writer struct {
	{{ range $n := .C.Fields.Names -}}
		{{- $f := ($.C.Fields.ByName $n) -}}
		{{- if not $f.Ignore -}}
			{{ ToTitleCase $f.Name }} {{ $f.QualifiedKind }} ` + "`" + `db:"{{ $f.QueryName }}"` + "`" + `
		{{- end }}
	{{ end -}}
}

func {{ ToSnakeCase .C.Message.Name }}WriterFromGeneric(y *{{ .C.Message.QualifiedKind }}) *{{ .C.Message.Name }}Writer {
	x := &{{ .C.Message.Name }}Writer{}
	{{ range $n := .C.Fields.Names -}}
		{{- $f := ($.C.Fields.ByName $n) -}}
		{{- if not $f.Ignore -}}
			x.{{ ToTitleCase $f.Name }} = y.{{ ToTitleCase $f.Name }}
		{{- end }}
	{{ end -}}
	return x
}
`

	tmpl, err := template.New("definePostgresStructs").
		Funcs(template.FuncMap{
			"ToSnakeCase": protocgenlib.ToSnakeCase,
			"ToTitleCase": protocgenlib.ToTitleCase,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Collection": c.File.QualifiedPackageName(c.File.DalPackagePath()),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineConfig() error {
	tmplSrc := `// {{ .C.Message.Name }}Config is a struct that can be used to configure a {{ .C.Message.Name }}Collection
type {{ .C.Message.Name }}Config struct {
	TableName string ` + "`" + `envconfig:"table"` + "`" + `
}
`

	tmpl, err := template.New("definePostgresConfig").
		Funcs(template.FuncMap{}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineTemplateProvider() error {
	tmplSrc := `{{- $Generate := "go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 ." -}}
// {{ .C.Message.Name }}QueryTemplateProvider is an interface that returns the query templated that should be executed
// to generate the queries that the collection will use.
//{{ $Generate }} {{ .C.Message.Name }}QueryTemplateProvider
type {{ .C.Message.Name }}QueryTemplateProvider interface {
	Insert() string
	Upsert() string
	Update() string
	All() string
	{{ range $qn := .C.Queries.Names -}}
		{{- $q := ($.C.Queries.ByName $qn) -}}
		{{- if $q.QueryProvided -}}
			{{ ToTitleCase $qn }}() string
		{{ end -}}
	{{ end -}}
}

// {{ .C.Message.Name }}Queries provides auto-generated queries when possible. This is not gauranteed to be a complete
// implementation of the interface. This should be used as a base for the actual query provider used.
type {{ .C.Message.Name }}Queries struct {
}

// Insert implements {{ .C.Message.Name }}QueryTemplateProvider.Insert.
func (x *{{ .C.Message.Name }}Queries) Insert() string {
	return ` + "`" + `INSERT INTO {{ "{{ .table }}" }}({{ "{{ .fields }}" }}) VALUES({{ "{{ .writeFields }}" }});` + "`" + `
}

// Upsert implements {{ .C.Message.Name }}QueryTemplateProvider.Upsert.
func (x *{{ .C.Message.Name }}Queries) Upsert() string {
	return ` + "`" + `INSERT INTO {{ "{{ .table }}" }}({{ "{{ .fields }}" }}) VALUES({{ "{{ .writeFields }}" }});` + "`" + `
}

// Update implements {{ .C.Message.Name }}QueryTemplateProvider.Update.
func (x *{{ .C.Message.Name }}Queries) Update() string {
	return ` + "`" + `UPDATE {{ "{{ .table }}" }} SET {{ "{{ .updates }}" }}{{ "{{ if .clause }} WHERE {{ .clause }}{{ end }}" }};` + "`" + `
}

// All implements {{ .C.Message.Name }}QueryTemplateProvider.All.
func (x *{{ .C.Message.Name }}Queries) All() string {
	return ` + "`" + `SELECT {{ "{{ .fields }}" }} FROM {{ "{{ .table }}" }};` + "`" + `
}

{{ range $qn := .C.Queries.Names -}}
	{{- $q := ($.C.Queries.ByName $qn) -}}
	{{- if $q.QueryImplemented -}}
		// {{- ToTitleCase $q.Name -}} implements {{ $.C.Message.Name }}QueryTemplateProvider.{{- ToTitleCase $q.Name -}}.
		func (x *{{ $.C.Message.Name }}Queries) {{- ToTitleCase $q.Name -}}() string {
			return ` + "`" + `SELECT {{ "{{ .fields }}" }} FROM {{ "{{ .table }}" }} WHERE
			1 = 1
			{{- range $a := $q.Args -}}
				{{- $arg := (Arg $.C.File $.C.Fields $a) -}}
				{{- "" }} AND
				{{ $arg.QueryName }} {{ $arg.Comparison }} :{{ $arg.QueryName }}
			{{- end -}};` + "`" + `
		}
	{{ end -}}
{{ end -}}
`

	tmpl, err := template.New("definePostgresTemplateProvider").
		Funcs(template.FuncMap{
			"Arg":         NewArg,
			"ToTitleCase": protocgenlib.ToTitleCase,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}
