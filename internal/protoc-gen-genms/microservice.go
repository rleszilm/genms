package generator

import (
	"bytes"
	"fmt"
	"path"
	"strings"
	"text/template"

	"github.com/go-test/deep"
	protocgenlib "github.com/rleszilm/genms/internal/protoc-gen-lib"
	"github.com/rleszilm/genms/protoc-gen-genms/annotations"
	"golang.org/x/tools/imports"
	"google.golang.org/protobuf/compiler/protogen"
)

// MicroService is a struct that generates a service file.
type MicroService struct {
	File    *protocgenlib.File
	Service *protocgenlib.Service
	Opts    *annotations.ServiceOptions

	plugin   *protogen.Plugin
	filename string
}

func (m *MicroService) render() error {
	steps := []func() error{
		m.definePackage,
		m.defineMicroService,
		m.defineService,
	}

	for _, s := range steps {
		if err := s(); err != nil {
			return err
		}
	}

	outfile := m.File.Outfile()
	original, err := outfile.Content()
	if err != nil {
		return err
	}
	formatted, err := imports.Process(m.filename, original, nil)
	if err != nil {
		return err
	}

	if diff := deep.Equal(original, formatted); diff != nil {
		formattedOutfile := m.plugin.NewGeneratedFile(m.filename, ".")
		if _, err := formattedOutfile.Write(formatted); err != nil {
			return err
		}
		outfile.Skip()
	}
	return nil
}

func (m *MicroService) definePackage() error {
	tmplSrc := `// Package {{ .File.PackageName }} is generated by protoc-gen-genms. *DO NOT EDIT*
package {{ .File.PackageName }}

`

	tmpl, err := template.New("definePackage").
		Funcs(template.FuncMap{}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, m); err != nil {
		return err
	}

	if _, err := m.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (m *MicroService) defineMicroService() error {
	tmplSrc := `
// {{ .M.Service.Name }}ServiceConfig defines the basic configuration for a {{ .M.Service.Name }}Service
type {{ .M.Service.Name }}ServiceConfig struct {
	Name string ` + "`envconfig:\"name\" default:\"{{ .M.Service.Name | ToDashCase | ToLower }}\"`" + `
	GrpcServer *{{ .P.GrpcService }}.Server ` + "`ignored:\"true\"`" + `
	{{ if .M.Opts.Http -}}HttpServer *{{ .P.HttpService }}.Server ` + "`ignored:\"true\"`" + `{{- end }}
	{{ if (or .M.Opts.Http) -}}Proxy *{{ .P.Service }}.Proxy ` + "`envconfig:\"proxy\"`" + `{{- end }}
}
	
// {{ .M.Service.Name }}Service implements {{ .M.Service.Name }}Service
type {{ .M.Service.Name }}Service struct {
	{{ .P.Service }}.UnimplementedService
	
	name string
	config *{{ .M.Service.Name }}ServiceConfig

	impl {{ .M.Service.Name }}Server
	grpcServer *{{ .P.GrpcService }}.Server
	{{ if .M.Opts.Http -}}httpServer *{{ .P.HttpService }}.Server{{- end }}
}

`

	tmpl, err := template.New("defineMicroService").
		Funcs(template.FuncMap{
			"ToDashCase": protocgenlib.ToDashCase,
			"ToLower":    strings.ToLower,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"GrpcService": m.File.QualifiedPackageName("github.com/rleszilm/genms/service/grpc"),
		"HttpService": m.File.QualifiedPackageName("github.com/rleszilm/genms/service/http"),
		"Service":     m.File.QualifiedPackageName("github.com/rleszilm/genms/service"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"M": m,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := m.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (m *MicroService) defineService() error {
	tmplSrc := `{{- $M := .M -}}
// Initialize implements service.Service.Initialize
func (s *{{ $M.Service.Name }}Service) Initialize(ctx {{ .P.Context }}.Context) error {
	if s.grpcServer != nil {
		s.grpcServer.WithService(func(server *{{ .P.GRPC }}.Server) {
			Register{{ $M.Service.Name }}Server(server, s.impl)
		})
	}
	{{ if $M.Opts.Http }}
		if s.httpServer != nil {
			if s.config != nil && s.config.Proxy != nil {
				if s.config.Proxy.Mode == "remote" {
					if err := s.httpServer.WithRemoteGrpcProxy(ctx, s.config.Proxy, Register{{ $M.Service.Name }}HandlerFromEndpoint); err != nil {
						return err
					}
				} else {
					localProxyRegistrar := func(ctx {{ .P.Context }}.Context, mux *{{ .P.Runtime }}.ServeMux) error {
						return Register{{ $M.Service.Name }}HandlerServer(ctx, mux, s.impl)
					}
					if err := s.httpServer.WithLocalGrpcProxy(ctx, s.config.Proxy, localProxyRegistrar); err != nil {
						return err
					}
				}
			}
		}
	{{- end }}
	return nil
}
// Shutdown implements service.Service.Shutdown
func (s *{{ $M.Service.Name }}Service) Shutdown(_ {{ .P.Context }}.Context) error {
	return nil
}

// String returns the name of the service
func (s *{{ $M.Service.Name }}Service) String() string {
	if s.name != "" {
		return s.name
	}
	return "{{ .M.Service.Name | ToDashCase | ToLower }}"
}

// WithName assigns a name to the service
func (s *{{ $M.Service.Name }}Service) WithName(name string) *{{ $M.Service.Name }}Service {
	s.name = name
	return s
}

// WithGrpcServer assigns a grpc server to the service.
func (s *{{ $M.Service.Name }}Service) WithGrpcServer(server *{{ .P.GrpcService }}.Server) *{{ $M.Service.Name }}Service {
	server.WithDependencies(s)
	s.grpcServer = server
	return s
}

{{ if $M.Opts.Http -}}
// WithHttpServer assigns a http server to the service.
func (s *{{ $M.Service.Name }}Service) WithHttpServer(server *{{ .P.HttpService }}.Server) *{{ $M.Service.Name }}Service {
	server.WithDependencies(s)
	s.httpServer = server
	return s
}
{{- end }}


// New{{ $M.Service.Name }}Service returns a new {{ $M.Service.Name }}Service
func New{{ $M.Service.Name }}Service(impl {{ $M.Service.Name }}Server, config *{{ $M.Service.Name }}ServiceConfig) *{{ $M.Service.Name }}Service {
	server := &{{ $M.Service.Name }}Service{
		name: config.Name,
		impl: impl,
		config: config,
		
		grpcServer: config.GrpcServer,
		{{ if $M.Opts.Http -}}httpServer: config.HttpServer,{{- end }}
	}

	if asService, ok := impl.({{ .P.Service }}.Service); ok {
		server.WithDependencies(asService)
	}

	return server
}
`

	tmpl, err := template.New("defineService").
		Funcs(template.FuncMap{
			"ToDashCase": protocgenlib.ToDashCase,
			"ToLower":    strings.ToLower,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Context":     m.File.QualifiedPackageName("context"),
		"GRPC":        m.File.QualifiedPackageName("google.golang.org/grpc"),
		"GrpcService": m.File.QualifiedPackageName("github.com/rleszilm/genms/service/grpc"),
		"Runtime":     m.File.QualifiedPackageName("github.com/grpc-ecosystem/grpc-gateway/v2/runtime"),
		"Service":     m.File.QualifiedPackageName("github.com/rleszilm/genms/service"),
	}
	if m.Opts.Http {
		p["HttpService"] = m.File.QualifiedPackageName("github.com/rleszilm/genms/service/http")
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"M": m,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := m.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

// NewMicroService returns a new collection renderer.
func NewMicroService(plugin *protogen.Plugin, file *protogen.File, svc *protogen.Service, opts *annotations.ServiceOptions) *MicroService {
	base := path.Base(file.GeneratedFilenamePrefix)
	dir := path.Dir(file.GeneratedFilenamePrefix)
	filename := path.Join(dir, fmt.Sprintf("%s.genms.%s.go", base, strings.ToLower(svc.GoName)))
	outfile := plugin.NewGeneratedFile(filename, ".")

	pfile := protocgenlib.NewFile(outfile, file)

	return &MicroService{
		File:     pfile,
		Service:  protocgenlib.NewService(pfile, svc),
		Opts:     opts,
		plugin:   plugin,
		filename: filename,
	}
}

// GenerateMicroService generates the dal interface for the collection
func GenerateMicroService(plugin *protogen.Plugin, file *protogen.File, svc *protogen.Service, opts *annotations.ServiceOptions) error {
	c := NewMicroService(plugin, file, svc, opts)
	return c.render()
}
