package generator

import (
	"bytes"
	"fmt"
	"path"
	"strings"
	"text/template"

	"github.com/go-test/deep"
	protocgenlib "github.com/rleszilm/genms/internal/protoc-gen-lib"
	"github.com/rleszilm/genms/protoc-gen-genms/annotations"
	"golang.org/x/tools/imports"
	"google.golang.org/protobuf/compiler/protogen"
)

// MicroService is a struct that generates a service file.
type MicroService struct {
	File    *protocgenlib.File
	Service *protocgenlib.Service
	Opts    *annotations.ServiceOptions

	plugin   *protogen.Plugin
	filename string
}

func (m *MicroService) render() error {
	steps := []func() error{
		m.definePackage,
		m.defineMicroService,
		m.defineService,
	}

	for _, s := range steps {
		if err := s(); err != nil {
			return err
		}
	}

	outfile := m.File.Outfile()
	original, err := outfile.Content()
	if err != nil {
		return err
	}
	formatted, err := imports.Process(m.filename, original, nil)

	if diff := deep.Equal(original, formatted); diff != nil {
		formattedOutfile := m.plugin.NewGeneratedFile(m.filename, ".")
		if _, err := formattedOutfile.Write(formatted); err != nil {
			return err
		}
		outfile.Skip()
	}
	return nil
}

func (m *MicroService) definePackage() error {
	tmplSrc := `// Package {{ .File.PackageName }} is generated by protoc-gen-genms. *DO NOT EDIT*
package {{ .File.PackageName }}

`

	tmpl, err := template.New("definePackage").
		Funcs(template.FuncMap{}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, m); err != nil {
		return err
	}

	if _, err := m.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (m *MicroService) defineMicroService() error {
	tmplSrc := `// {{ .M.Service.Name }}ServerService implements {{ .M.Service.Name }}Service
type {{ .M.Service.Name }}ServerService struct {
	{{ .P.Service }}.Dependencies
	
	impl {{ .M.Service.Name }}Server
	grpcServer *{{ .P.GRPCService }}.Server
	{{ if .M.Opts.Rest -}}restServer *{{ .P.RESTService }}.Server{{- end }}
	{{ if .M.Opts.Graphql -}} graphqlServer *{{ .P.GraphQLService }}.Server {{- end }}
	{{ if (or .M.Opts.Rest .M.Opts.Graphql) -}}proxy *{{ .P.GRPCService }}.Proxy{{- end }}
}

`

	tmpl, err := template.New("defineMicroService").
		Funcs(template.FuncMap{}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"GRPCService":    m.File.QualifiedPackageName("github.com/rleszilm/genms/service/grpc"),
		"GraphQLService": m.File.QualifiedPackageName("github.com/rleszilm/genms/service/graphql"),
		"RESTService":    m.File.QualifiedPackageName("github.com/rleszilm/genms/service/rest"),
		"Service":        m.File.QualifiedPackageName("github.com/rleszilm/genms/service"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"M": m,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := m.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (m *MicroService) defineService() error {
	tmplSrc := `{{- $M := .M -}}
// Initialize implements service.Service.Initialize
func (s *{{ $M.Service.Name }}ServerService) Initialize(ctx {{ .P.Context }}.Context) error {
	s.grpcServer.WithService(func(server *{{ .P.GRPC }}.Server) {
		Register{{ $M.Service.Name }}Server(server, s.impl)
	})
	{{ if $M.Opts.Rest }}
		if err := s.restServer.WithGrpcProxy(ctx, s.proxy, Register{{ $M.Service.Name }}HandlerFromEndpoint); err != nil {
			return err
		}
	{{- end }}
	{{ if $M.Opts.Graphql }}
		if err := s.graphqlServer.WithGrpcProxy(ctx, s.proxy, Register{{ $M.Service.Name }}GraphqlWithOptions); err != nil {
			return err
		}
	{{- end }}
	return nil
}
// Shutdown implements service.Service.Shutdown
func (s *{{ $M.Service.Name }}ServerService) Shutdown(_ {{ .P.Context }}.Context) error {
	return nil
}

// ID returns the name of the service
func (s *{{ $M.Service.Name }}ServerService) ID() string {
	return "{{ $M.Service.Name | ToDashCase | ToLower }}"
}

// New{{ $M.Service.Name }}ServerService returns a new {{ $M.Service.Name }}ServerService
func New{{ $M.Service.Name }}ServerService(impl {{ $M.Service.Name }}Server, grpcServer *{{ .P.GRPCService }}.Server
	{{- if $M.Opts.Rest -}}, restServer *{{ .P.RESTService }}.Server{{- end -}}
	{{- if $M.Opts.Graphql -}}, graphqlServer *{{ .P.GraphQLService }}.Server{{- end -}}
	{{- if (or $M.Opts.Rest $M.Opts.Graphql) }}, proxy *{{ .P.GRPCService }}.Proxy{{- end -}}
) *{{ $M.Service.Name }}ServerService {
	server := &{{ $M.Service.Name }}ServerService{
		impl: impl,
		grpcServer: grpcServer,
		{{ if $M.Opts.Graphql -}} graphqlServer: graphqlServer,{{- end }}
		{{ if $M.Opts.Rest -}} restServer: restServer,{{- end }}
		{{ if (or $M.Opts.Graphql $M.Opts.Rest) -}}proxy: proxy,{{- end }}
	}

	if asService, ok := impl.({{ .P.Service }}.Service); ok {
		server.WithDependencies(asService)
	}

	grpcServer.WithDependencies(server)
	{{ if $M.Opts.Rest -}}
		restServer.WithDependencies(server)
	{{- end }}
	{{ if $M.Opts.Graphql -}}
		graphqlServer.WithDependencies(server)
	{{- end }}
	return server
}
`

	tmpl, err := template.New("defineService").
		Funcs(template.FuncMap{
			"ToLower":    strings.ToLower,
			"ToDashCase": protocgenlib.ToDashCase,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Context":     m.File.QualifiedPackageName("context"),
		"GRPC":        m.File.QualifiedPackageName("google.golang.org/grpc"),
		"GRPCService": m.File.QualifiedPackageName("github.com/rleszilm/genms/service/grpc"),
		"Service":     m.File.QualifiedPackageName("github.com/rleszilm/genms/service"),
	}
	if m.Opts.Graphql {
		p["GraphQLService"] = m.File.QualifiedPackageName("github.com/rleszilm/genms/service/graphql")
	}
	if m.Opts.Rest {
		p["RESTService"] = m.File.QualifiedPackageName("github.com/rleszilm/genms/service/rest")
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"M": m,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := m.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

// NewMicroService returns a new collection renderer.
func NewMicroService(plugin *protogen.Plugin, file *protogen.File, svc *protogen.Service, opts *annotations.ServiceOptions) *MicroService {
	base := path.Base(file.GeneratedFilenamePrefix)
	dir := path.Dir(file.GeneratedFilenamePrefix)
	filename := path.Join(dir, fmt.Sprintf("%s.genms.%s.go", base, strings.ToLower(svc.GoName)))
	outfile := plugin.NewGeneratedFile(filename, ".")

	pfile := protocgenlib.NewFile(outfile, file)

	return &MicroService{
		File:     pfile,
		Service:  protocgenlib.NewService(pfile, svc),
		Opts:     opts,
		plugin:   plugin,
		filename: filename,
	}
}

// GenerateMicroService generates the dal interface for the collection
func GenerateMicroService(plugin *protogen.Plugin, file *protogen.File, svc *protogen.Service, opts *annotations.ServiceOptions) error {
	c := NewMicroService(plugin, file, svc, opts)
	return c.render()
}
